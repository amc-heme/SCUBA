---
title: "User Guide"
output: 
  html_document:
    theme:
      bslib: true
      version: 5
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{scss document_css, echo = FALSE}
/* CSS variables */
:root {
  --rs_blue: #217CA1;
}


/* Centers text and block elements */
.center{
  text-align: center;
  /* Display must be set to block for centering to work */
  display: block;
  }

.white-text{
  color: white;
}

/* Bootstrap card elements */
.card-header{
  background-color: #CFB87C;
  /* Adds a mrgin-top of 0 to the existing bootstrap class to remove white space
   that appears when using the card component in an Rmd */
  margin-top: 0px;
}

.card-body{
  background-color: #E1E1E1; 
  /* The border radius property is not properly inherited from the parent .card
    element. The reason is unkown, but explicitly defining it here fixes 
    the issue */
  border-radius: 0px 0px var(--bs-card-border-radius) var(--bs-card-border-radius);
}

/* CSS for callouts
   From https://codepen.io/superjaberwocky/pen/rLKxOa */
   /* Requires SASS to be enabled, with sass package and "scss" code chunk*/
.callout {
  padding: 20px;
  margin: 20px 0;
  border: 1px solid #eee;
  /* If the border-radius is greater than border-left-width,  
     the left border will curve inward onto the element's body,
     creating a cresent-like shape*/
  border-left-width: 8px;
  border-radius: 8px;
  h4, h5 {
    margin-top: 0;
    margin-bottom: 5px;
  }
  p:last-child {
    margin-bottom: 0;
  }
  code {
    border-radius: 3px;
  }
  & + .bs-callout {
    margin-top: -5px;
  }
}

/* Define properties for default, primary, info, etc. classes*/
@each $name,$color in 
  (default,#777),
  (primary,#428bca),
  (success,#5cb85c),
  (danger,#d9534f),
  (warning,#f0ad4e),
  (info,#5bc0de), 
  (bdc,#29527a){
  .callout-#{$name} {
    border-left-color: $color;
    /* Background: color above, with an alpha hex value of '35'*/
    background-color: #{$color + '35'};
    h4, h5 {
      color: $color;
    }
  }
}

/* Applied to output of code chunks. Causes a scrollbar to appear 
   when the output extends beyond the max-height. */
/* Adapted from https://bookdown.org/yihui/rmarkdown-cookbook/html-scroll.html */
/* Classes are defined for several max heights */
@each $height in 
  80,
  100,
  300{
  .scroll-#{$height} {
    max-height: #{$height + "px"};
    overflow-y: auto;
    background-color: inherit;
  }
}

/*
.scroll-80 {
  max-height: 80px;
  overflow-y: auto;
  background-color: inherit;
}

.scroll-100 {
  max-height: 100px;
  overflow-y: auto;
  background-color: inherit;
}

.scroll-300 {
  max-height: 300px;
  overflow-y: auto;
  background-color: inherit;
}*/

/* Accordion Menu CSS */
details {
  /* Add spacing beneath each accordion menu */
  margin-bottom: 10px;
}

.header{
    /* Background: RS steel blue */ 
    background-color: #217CA1; /*var(rs-blue, #0088A1);*/
    color: #FFFFFF;
    /* Rounds corners of header */
    border-radius: 5px;
    /* To make the layout less crowded, the padding property 
       adds spacing between the text and the edge of the header.
       The two-element attribute specification below adds 5 px to the top and 
       bottom edges, and 15 px to the left and right edges.
       */
    padding: 5px 15px;
    /* Makes text 1.17 times larger than normal text in R markdown (<h3> size)*/
    font-size: 1.17em;
}

/* Header text is enclosed in a span element, with spacing before the element */
.header span {
  margin-left: 8px;
}

.content{
    background-color: #E1E1E1;
    /* Adds 15 px of padding on all four edges of content */
    padding: 15px;
}

/* The classes below apply only when the accordion menu is open */
/* The goal of the CSS declarations below is to round all corners of the whole 
   accordion menu, which consists of both the header and the content when the 
   menu is open. This requires the edge between the header and content to have
   square corners so these two elements appear contiguous with each other. */
details[open] .header{
    /* Use the border radius to round the top corners, and leave the bottom 
       corners square */
    border-radius: 10px 10px 0px 0px;
}

details[open] .content{
    /* Rounds the bottom-left and bottom-right corners of the content element, 
       while leaving the top corners square.*/
    border-radius: 0px 0px 10px 10px;
}

/* Tabset panel for examples */
/* Tabset "pills" appear for each object type. Users click the tab and see code 
  and information for each object */
/* For each */
@each $obj_name,$color in 
  (seurat,#0072B2),
  (singlecellexperiment,#009E73),
  (anndata,#D55E00),
  // will need to add a text color to go with the background colors here 
  // All wite or all black will not work with all colors here
  (mudata,#FED105){
  // Style for buttons forming tabset "pills"
  button.#{$obj_name} {
    border: solid 1px;
    border-color: #000000;
    /* Shape like a true "tab", like those on manilla folders */
    border-radius: 10px 10px 0px 0px !important;
    /* Background when inactive: color above, but with reduced alpha'*/
    background-color: #{$color + '99'} !important;
    /* Text color: black when inactive, white when active */
    color: #000000 !important;
    }
    
  button.#{$obj_name}:hover{
    color: #FFFFFF !important;
  }
   
  button.#{$obj_name}.active{
    /* Text color: gray when inactive, white when active */
    color: #FFFFFF !important;
    /* Use full alpha for active tabs */
    background-color: $color !important;
    /* Print a boarder the same color as the tab below active tabs, which will 
      override the black boarder around the top of the content (appearing as 
      no boarder, with the tab directly feeding into the content) */
    border-bottom-color: $color;
  }
  
  /* Code blocks in each tab */
  div[id*=#{$obj_name}] pre {
    /* background color: object color above, with very low alpha */
    background-color: #{$color + '11'};
  }
} 

/* Change boarder around content to black */
div.tab-content{
  border-color: #000000 !important; 
  border-radius: 0px 10px 10px 10px;
}

/* Fixes whitespace issue in tabset panel */
/* Pkgdown websites use Bootstrap for tabset panels */
/* Bootstrap uses visibility: hidden for inactive tabs, which hides the 
   element, but doesn't set its height to 0. When tabsets are created with 
   content that is unequal in height (much more content in one panel than 
   others), the panel's height doesn't re-size to match content, and the result 
   is large amounts of white space when viewing the tabs with shorter content. */
/* The display attribute is more appropriate and should be used instead.*/
/* Inactive tabs: hide */
.tab-content .tab-pane{
  display: none !important;
}

/* Active tabs: show */
.tab-content .active {
  display: block !important;
}
```

```{js tab pills script, echo=FALSE}
// Custom JavaScript for tabset/navbar panels
// Panels have classes for each object type, that need to map to both the <div>
// containing examples for each object, *and* the <button> tags in the tabset 
// pills that are used to change tabs.
// The default markdown syntax for tabset pills only applies classes to the 
// <div>. Here, it is also applied to the <button> tags.
$(document).ready(function(){
  // Find the tabset using the .tabset class and locate the decendent <button> 
  // tags. This only works on the pkgdown site (Rmd docs use <a> instead, and 
  // and do not appear to properly interperet JavaScript, at least in the R 
  // Studio browser)
  // .nav-pills.special-tabs: only apply classes to navbar menus with 
  // special-tabs class (there are other navbars on the pkgdown website)
  document.querySelectorAll(".nav-pills button").forEach(tab => {
      // console.log(tab)
       if (tab.textContent.trim() === "Seurat") {
           tab.classList.add("seurat");
       } else if (tab.textContent.trim() === "SingleCellExperiment"){
           tab.classList.add("singlecellexperiment");
       } else if (tab.textContent.trim() === "anndata") {
           tab.classList.add("anndata");
       }
   });
});

// document.addEventListener("DOMContentLoaded", function() {
//    
// });
```

SCUBA provides several functions for exploration, access, and visualization of data from single-cell objects. Each of these is covered here, for each object type supported by SCUBA. SCUBA currently supports Seurat, SingleCellExperiment, and anndata objects.

<!-- TODO: ADD NOTE ABOUT DIFFERENCES IN NAMING CONVENTIONS BETWEEN OBJECTS. ALSO ADD TABLE. -->

```{r}
# Load package
library(SCUBA)
```

<!-- Starting with header 2 because header 1 tags in pkgdown keep the tabset pills 
     present in this document from rendering properly in pkgdown -->
<!-- https://github.com/r-lib/pkgdown/issues/2720 -->
<!--     ¯\_(ツ)_/¯     -->

## Data Access

The primary data access method in SCUBA is `fetch_data`. This function replicates the behavior of `fetch_data` in the `SeuratObject` package. This function is an S3 generic that executes methods based on the object type. When a Seurat object is passed to `fetch_data`, the `fetch_data` method from the `SeuratObject` package is ran. When SingleCellExperiment or anndata objects are passed, methods from SCUBA are dispatched that replicate the behavior of `fetch_data` in these objects.

`fetch_data` can be used to fetch either feature expression data, metadata, or reduction coordinates, all of which are fetched using the same parameter, `vars`. For each entry passed to `vars`, `fetch_data` will automatically identify the type of data matching the input and retrieve the data accordingly. 

### Fetching Expression Data

`fetch_data` can retrieve feature expression data from any assay in the object (or "experiment" in SingleCellExperiment and "modality" in anndata objects). To retrieve feature expression data, you can pass any number of features to the `vars` parameter.

Features may have the same name across different assays/experiments/modalities. For example, there may be data for both CD4 gene and surface protein expression, or there may be both gene expression and chromatin accessibility data for the same gene. To ensure feature data from the correct modality is returned, `fetch_data` implements a syntax where a "key" is specified before the feature name, with an underscore separating the key and the feature name.

```
{"key" of the modality} + "_" + {feature name}
```

To determine the key to enter for the desired modality, we provide the `all_keys()` utility function. The output is a named character vector, with names equal to the name of the modality, and values equal to the key to use.

<!-- fetch_data expression data examples -->
#### {.tabset .tabset-pills}
##### Seurat 

```{r}
all_keys(AML_Seurat)
```

In this example object, use the "rna" key to pull data from the "RNA" assay. 

To pull gene expression data for FLT3, for example, you would pass "rna_FLT3" to `vars`.

```{r}
fetch_data(
  AML_Seurat,
  vars = "rna_FLT3"
  ) |>
  # First 10 rows are shown for this example
  head(10)
```

##### SingleCellExperiment

```{r}
all_keys(AML_SCE())
```

In this example object, use the "RNA" key to pull data from the "RNA" assay. 

To pull gene expression data for FLT3, for example, you would pass "RNA_FLT3" to `vars`.

```{r}
fetch_data(
  AML_SCE(),
  vars = "RNA_FLT3"
  ) |>
  # First 10 rows are shown for this example
  head(10)
```

##### anndata

```{r}
all_keys(AML_h5ad())
```

By convention, the gene expression modality in anndata objects is named "X". In this example object, use the "X" key to pull data from the "RNA" assay.

To pull gene expression data for FLT3, for example, you would pass "X_FLT3" to `vars`.

```{r}
fetch_data(
  AML_h5ad(),
  vars = "X_FLT3"
  ) |>
  # First 10 rows are shown for this example
  head(10)
```

#### {.tabset .tabset-pills}

Any number of features can be passed to vars as a character vector. To view available features for a modality, SCUBA provides the `features_in_assay` generic. Use the `assay` parameter to specify the modality, using the name instead of the key. This utility generic can be used to query available features in a modality, and check if a feature is represented in the data for the assay before passage to fetch_data. 

##### Seurat

```{r}
available_genes <-
  features_in_assay(
    AML_Seurat,
    # For this object, "RNA" is the gene expression assay
    assay = "RNA"
  )

available_genes |> 
  head(10)

# Test if a gene is present in the RNA assay before passage to fetch_data
"MEIS1" %in% available_genes

# Request data for multiple features
fetch_data(
  AML_Seurat,
  vars = c("rna_FLT3", "rna_MEIS1")
  ) |>
  head(10)
```

##### SingleCellExperiment

```{r}
available_genes <-
  features_in_assay(
    AML_SCE(),
    # In this object, RNA is the name of the gene expression experiment
    assay = "RNA"
  )

available_genes |> 
  head(10)

# Test if a gene is present in the RNA assay before passage to fetch_data
"MEIS1" %in% available_genes

# Request data for multiple features
fetch_data(
  AML_SCE(),
  vars = c("RNA_FLT3", "RNA_MEIS1")
  ) |>
  head(10)
```

##### anndata

```{r}
available_genes <-
  features_in_assay(
    AML_h5ad(),
    assay = "X"
  )

available_genes |> 
  head(10)

# Test if a gene is present in the RNA assay before passage to fetch_data
"MEIS1" %in% available_genes

# Request data for multiple features
fetch_data(
  AML_h5ad(),
  vars = c("X_FLT3", "X_MEIS1")
  ) |>
  head(10)
```

<!-- {-} Ends tabset interface -->
#### {-}

### Expression Data from Alternate Layers 

By default, `fetch_data` will pull data from the normalized counts layer. In Seurat objects, this is the "Data" layer and in SingleCellExperiment objects, this is "logcounts". In anndata objects, it is customary to store normalized count data in the X matrix. (If normalized counts data in your object is stored elsewhere, see the "anndata" tab below.)

To pull data from alternate layers, use the `layer` parameter.

<!-- Tabset interface uses an <h5> header since this is subordinate to the 
    <h4> section above -->
#### {.tabset .tabset-pills}

<!-- Tabset buttons are rendered properly as long as they are one header level
    subordinate of the .tabset element -->
##### Seurat

Below, feature expression data is pulled from raw counts (the `counts` slot).

```{r}
fetch_data(
  AML_Seurat,
  vars = c("rna_FLT3", "rna_MEIS1"),
  slot = "counts"
  ) |>
  head(10)
```

<div class="callout callout-info">
  <h4>Note</h4>
  <p>In Seurat v4 and earlier, the `layer` parameter was named `slot`. If you are using Seurat v4 or earlier, you will need to use `slot` instead of `layer`. This difference does not affect SingleCellExperiment or anndata objects: for these objects, only `layer` should be used. </p>
</div>

##### SingleCellExperiment

Below, feature expression data is pulled from raw counts (the `counts` layer, referred to as the `counts` "assay" in SingleCellExperiment).

```{r}
fetch_data(
  AML_SCE(),
  vars = c("RNA_FLT3", "RNA_MEIS1"),
  layer = "counts"
  ) |>
  head(10)
```

##### anndata

If the layer parameter is undefined for anndata objects, `fetch_data` will use whichever matrix is present in X. If normalized counts data is stored in an alternate layer in the `layers` slot, the name of that layer must be passed to `layers` to retrieve the normalized counts matrix.

In the example object below, normalized counts are stored in X, and raw counts are stored in an alternate layer named "counts". 

```{r}
# Raw counts in "counts"
fetch_data(
  AML_h5ad(),
  vars = c("X_FLT3", "X_MEIS1"),
  layer = "counts"
  ) |>
  head(10)

# Normalized counts in X
fetch_data(
  AML_h5ad(),
  vars = c("X_FLT3", "X_MEIS1")
  ) |>
  head(10)
```

### Fetching Metadata

To retrieve metadata, pass the name of the metadata variable to fetch to the `vars` parameter of `fetch_data`. You can pass any number of metadata variables to `vars` as a character vector. Any metadata variable in the object can be retrieved, and there are no differences in input between categorical and numeric metadata variables.

#### {.tabset .tabset-pills}

##### Seurat

```{r}
fetch_data(
  AML_Seurat,
  vars = c("condensed_cell_type", "Batch", "nCount_RNA")
  ) |>
  # head is used in this example since metadata will be returned for all cells
  head(10)
```

##### SingleCellExperiment

```{r}
fetch_data(
  AML_SCE(),
  vars = c("condensed_cell_type", "Batch", "nCount_RNA")
  ) |>
  # head is used in this example since metadata will be returned for all cells
  head(10)
```

##### anndata

```{r}
fetch_data(
  AML_h5ad(),
  vars = c("condensed_cell_type", "Batch", "nCount_RNA")
  ) |>
  # head is used in this example since metadata will be returned for all cells
  head(10)
```

<!-- Empty section header ends tabset and keeps paragraph beneath from appearing
    under "anndata" tab -->
#### {-}

If you are retrieving just metadata from very large single-cell objects, we offer a `fetch_metadata` method that is faster than using `fetch_data`. As with `fetch_data`, desired metadata variables are passed to `vars`.

#### {.tabset .tabset-pills}

##### Seurat

```{r}
fetch_metadata(
  AML_Seurat,
  vars = c("condensed_cell_type", "Batch", "nCount_RNA")
  ) |>
  # head is used in this example since metadata will be returned for all cells
  head(10)
```

##### SingleCellExperiment

```{r}
fetch_metadata(
  AML_SCE(),
  vars = c("condensed_cell_type", "Batch", "nCount_RNA")
  ) |>
  # head is used in this example since metadata will be returned for all cells
  head(10)
```

##### anndata

<div class="callout callout-info">
  <h4>Note</h4>
  <p>In anndata objects, `fetch_metadata` does not offer performance advantages over `fetch_data`.</p>
</div>

```{r}
fetch_metadata(
  AML_h5ad(),
  vars = c("condensed_cell_type", "Batch", "nCount_RNA")
  ) |>
  # head is used in this example since metadata will be returned for all cells
  head(10)
```

<!-- Empty section header ends tabset and keeps content beneath from appearing
    under "anndata" tab -->
#### {-}

If you are only requesting one variable, you can request results to be returned as a vector rather than as a data.frame. 

For example, if you are attempting to view the unique cell types represented in an object, the output of `fetch_metadata` will need to be a vector. 

#### {.tabset .tabset-pills}

##### Seurat

```{r}
fetch_metadata(
  AML_Seurat,
  vars = "condensed_cell_type",
  return_class = "vector"
  ) |>
  # The unique() function requires a vector as input
  unique()
```

##### SingleCellExperiment

```{r}
fetch_metadata(
  AML_SCE(),
  vars = "condensed_cell_type",
  return_class = "vector"
  ) |>
  # The unique() function requires a vector as input
  unique()
```

##### anndata

```{r}
fetch_metadata(
  AML_h5ad(),
  vars = "condensed_cell_type",
  return_class = "vector"
  ) |>
  # The unique() function requires a vector as input
  unique()
```

#### {-}

In a programming context, it may also be useful to pull the full table. This can be done with `fetch_metadata` using the `full_table` parameter.

#### {.tabset .tabset-pills}

##### Seurat

```{r}
fetch_metadata(
  AML_Seurat,
  full_table = TRUE
  ) |>
  # head is used in this example since metadata will be returned for all cells
  head(10)
```

##### SingleCellExperiment

```{r}
fetch_metadata(
  AML_SCE(),
  full_table = TRUE
  ) |>
  # head is used in this example since metadata will be returned for all cells
  head(10)
```

##### anndata

```{r}
fetch_metadata(
  AML_h5ad(),
  full_table = TRUE
  ) |>
  # head is used in this example since metadata will be returned for all cells
  head(10)
```

### Fetching Reduction Coordinates

In a similar manner to expression data, reduction coordinates to fetch are passed to `vars` using a "key" and underscore system. In this case, you would enter the key of the reduction to use, and an integer specifying the dimension of the reduction to pull from.

```
{"key" of the reduction} + "_" + {dimension}
```

As with assays/modalities, run `all_keys` to see the key corresponding to the reduction you would like to pull data from. Examples for each object type are provided below.

#### {.tabset .tabset-pills}

##### Seurat

From running `all_keys()`, the key of the UMAP reduction in this object is "UMAP_". 

```{r}
all_keys(AML_Seurat)
```

To fetch the first and second dims, pass "UMAP_1" and "UMAP_2" to `vars`.

```{r}
fetch_data(
  AML_Seurat,
  vars = c("UMAP_1", "UMAP_2")
  ) |>
  head(10)
```

##### SingleCellExperiment

From running `all_keys()`, the key of the UMAP reduction in this object is "UMAP_". 

```{r}
all_keys(AML_SCE())
```

To fetch the first and second dims, pass "UMAP_1" and "UMAP_2" to `vars`.

```{r}
fetch_data(
  AML_SCE(),
  vars = c("UMAP_1", "UMAP_2")
  ) |>
  head(10)
```

##### anndata

From running `all_keys()`, the key of the UMAP reduction in this object is "X_umap_".

```{r}
all_keys(AML_h5ad())
```

To fetch the first and second dims, pass "X_umap_1" and "X_umap_2" to `vars`.

```{r}
fetch_data(
  AML_h5ad(),
  vars = c("X_umap_1", "X_umap_2")
  ) |>
  head(10)
```

## Data Exploration

### View Overall Metadata Present

To view the names of all metadata metadata variables in the object, use `meta_varnames`.

#### {.tabset .tabset-pills .special-tabs}

##### Seurat

```{r}
meta_varnames(
  AML_Seurat
)
```

##### SingleCellExperiment

```{r}
meta_varnames(
  AML_SCE()
)
```

##### anndata

```{r}
meta_varnames(
  AML_h5ad()
)
```

### Summarize a Metadata Variable

To explore a metadata variable in greater detail, use `unique_values`. This will print all values within the metadata variable. This is done below with the "condensed_cell_type" variable identified from `meta_varnames`.

To view the unique values for a variable, pass the name of the variable to the `var` parameter of the `unique_values` function. 

#### {.tabset .tabset-pills}

##### Seurat

```{r, class.source='seurat', class.output='seurat'}
unique_values(
  AML_Seurat,
  var = "condensed_cell_type"
)
```

##### SingleCellExperiment

```{r, class.source=".sce", class.output=".sce"}
unique_values(
  AML_SCE(),
  var = "condensed_cell_type"
)
```

##### anndata

```{r, class.source=".anndata", class.output=".anndata"}
unique_values(
  AML_h5ad(),
  var = "condensed_cell_type"
)
```

## Data Visualization


