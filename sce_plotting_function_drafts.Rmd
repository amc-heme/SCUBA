---
title: "SCE plotting_function_drafts"
output: html_document
date: "2023-02-13"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(Seurat)
library(SingleCellExperiment)
library(DelayedArray)
library(HDF5Array)
library(DelayedMatrixStats)

library(ggplot2)
library(dplyr)

# Directory for SingleCellExperiment HDF5 version 
# SCE object is derived from the Cancer Discovery Seurat object
hdf5Dir <-
  "data/sce_hdf5/"

sce <- loadHDF5SummarizedExperiment(dir = hdf5Dir)
```

# UMAP function

The code below is based on the Seurat::DimPlot function, while leaving lower-level functions intact (for now).

The version below is written for SingleCellExperiment objects only. Later, a combined function that accepts both Seurat and SCE objects will be created.

```{r}
# User arguments ####
object <- sce
reduction <- "UMAP"
group_by <- "named_clusters"
shape_by <- NULL#"named_clusters"
split_by <- "sample"
# Test subset (1,40, 56)
cells <- NULL #c("DX_AAACCCAAGCGTATAA","DX_AACAACCGTTAGTTCG", "DX_AACCATGTCTCTATGT")
dims <- c(1, 2)
# Uses same default seed as Seurat::DimPlot to yield comparable results
seed <- 1

cols = NULL
pt_size = NULL
order = NULL
shuffle = FALSE
label = FALSE
label_size = 4
label_color = 'black'
label_box = FALSE
repel = FALSE
cells_highlight = NULL
cols_highlight = '#DE2D26'
sizes_highlight = 1
na_value = 'grey50'
ncol = NULL
combine = TRUE
raster = NULL
raster_dpi = c(512, 512)

#####
# 1. Define reduction (defaults to the first reduction stored for sce objects)
# Uses rlang %||% infix
reduction <- reduction %||% SingleCellExperiment::reducedDimNames(object)[1]
# 2. Define cells to include in plot
## Same as for seurat object ##
cells <- cells %||% BiocGenerics::colnames(object) 

# 3. Fetch dimensional reduction data from object
data <- SingleCellExperiment::reducedDims(object)[[reduction]][cells, dims]
data <- BiocGenerics::as.data.frame(data)

# 4. Fetch names of dimensions to plot
# For SCE objects, use the column names for the requested dim indices
# (there is no `Key()` method for SingleCellExperiment objects)
dim_names <- colnames(data)[dims]

# 5. Process group by selection
# There is no "ident" property for SingleCellExperiment objects, so defaults 
# will be chosen based on the first metadata column, rather than the current ident class
# Store original entry for group_by
orig_groups <- group_by

if (is.null(group_by)){
  warning("group_by is NULL. Defaulting to the first column in colData.")
  group_by <- names(colData(object))[1]
}

# 6. Bind group by metadata to the table of reduction coordinates
data <-
  cbind(
    data,
    # Subsets for selected cells, and the names of entered group_by columns
    colData(object)[cells, group_by, drop = FALSE]
    )

# 7. Define group_by variables to iterate through
group_by_cols <-
  colnames(data)[3:ncol(data)]

# 8. Convert group by columns to factors if they are not already
for (group in group_by_cols) {
  if (!is.factor(data[, group])) {
    data[, group] <- factor(data[, group])
  }
}

# 9. Add shape_by data if it exists
if (!is.null(x = shape_by)) {
  data[, shape_by] <- colData(object)[cells, shape_by, drop = TRUE]
}

# 10. Same for split_by data
if (!is.null(x = split_by)) {
  data[, split_by] <- colData(object)[cells, split_by, drop = TRUE]
}

# 11. If sufffle is TRUE, randomly shuffle cells
if (isTRUE(shuffle)) {
    set.seed(seed = seed)
    data <- data[sample(x = 1:nrow(x = data)), ]
  }

# 12. Create a plot for each group_by variable in group_by_cols
plots <- 
  lapply(
    X = group_by,
    FUN = function(group) {
      plot <- Seurat::SingleDimPlot(
        data = data[, c(dim_names, group, split_by, shape_by)],
        dims = dim_names,
        col.by = group,
        # cols: a categorical pallete in this case
        cols = cols,
        pt.size = pt_size,
        shape.by = shape_by,
        order = order,
        label = FALSE,
        # Cells to highlight
        cells.highlight = cells_highlight,
        cols.highlight = cols_highlight,
        sizes.highlight = sizes_highlight,
        na.value = na_value,
        raster = raster,
        raster.dpi = raster_dpi
      )
      if (label) {
        plot <- Seurat::LabelClusters(
          plot = plot,
          id = group,
          repel = repel,
          size = label_size,
          split.by = split_by,
          box = label_box,
          color = label_color
        )
      }
      if (!is.null(x = split_by)) {
        plot <- 
          plot + 
          Seurat:::FacetTheme() +
          ggplot2::facet_wrap(
            # rlang injection operator
            # ?`!!` for more information
            facets = vars(!!sym(x = split_by)),
            ncol = if (length(x = group_by) > 1 || is.null(x = ncol)) {
              length(x = unique(x = data[, split_by]))
            } else {
              ncol
            }
          )
      }
      plot <- if (is.null(x = orig_groups)) {
        plot + labs(title = NULL)
      } else {
        plot + CenterTitle()
      }
    }
  )
  if (!is.null(x = split_by)) {
    ncol <- 1
  }
  if (combine) {
    plots <- 
      patchwork::wrap_plots(
        plots, 
        # %iff% infix (Seurat package)
        # Uses ncol if orig.groups is not NULL, otherwise uses ncol >:(
        ncol = orig_groups %iff% ncol
        )
  }
 
plots 
#return(plots)
```
```{r}
Seurat::DimPlot(
  object = sobj,
  group.by = "named_clusters",
  split.by = "sample"
)
```




# Seurat code for DimPlot
```{r}
# Seurat code
object <- sobj
group.by <- "named_clusters"
shape.by <- "sample"
reduction <- "umap"

if (length(x = dims) != 2) {
    stop("'dims' must be a two-length vector")
  }
  # Determine reduction to use (if NULL, use default))
  # %||% infix is from rlang
  reduction <- reduction %||% DefaultDimReduc(object = object)
  # Read parameter for cells to plot (defaults to all cells)
  cells <- cells %||% colnames(x = object)
  
  # Fetch data for chosen reduction from object 
  # subset for chosen cells and dims 
  data <- Embeddings(object = object[[reduction]])[cells, dims]
  # Convert to data.frame (default is a matrix)
  data <- as.data.frame(x = data)
  # Form names for dim reduction coordinates on the x- and y- axis
  dims <- 
    paste0(
      # Use the key of the *reduction* chosen by the 
      # user (or the default reduction)
      Key(object = object[[reduction]]), 
      dims
      )
  
  # Store current ident class
  object[['ident']] <- Idents(object = object)
  # Store group by variable in `orig.groups`
  orig.groups <- group.by
  # Define the group by variable, using ident column if undefined
  group.by <- group.by %||% 'ident'
  
  # Add values of the group.by metadata variable(s) for 
  # each cell to the reduction data
  data <- 
    cbind(
      data, 
      object[[group.by]][cells, , drop = FALSE]
      )
  
  # Explicitly define group.by as the column names for each metadata variable
  # added to the reduction matrix above
  group.by <- colnames(x = data)[3:ncol(x = data)]

  # If any of the metadata columns are not factors, coerce them into factors.
  for (group in group.by) {
    if (!is.factor(x = data[, group])) {
      data[, group] <- factor(x = data[, group])
    }
  }
  
  # Add data for shape.by metadata variable if it exists
  if (!is.null(x = shape.by)) {
    data[, shape.by] <- object[[shape.by, drop = TRUE]]
  }
  
  # Same for split.by metadata variable
  if (!is.null(x = split.by)) {
    data[, split.by] <- object[[split.by, drop = TRUE]]
  }
```

# Test SCEPlots::DimPlot

```{r}
sce <- loadHDF5SummarizedExperiment(dir = hdf5Dir)

# SCE object
SCEPlots::DimPlot(
  object = sce,
  reduction = "UMAP",
  group_by = "named_clusters",
  split_by = "sample"
)
```
```{r}
sobj <- readRDS("../scExploreR_files/scExploreR/Seurat_Objects/Cancer_discovery_object/pei_cd_20221122.Rds")

SCEPlots::DimPlot(
  object = sobj,
  reduction = "umap",
  group_by = "named_clusters",
  split_by = "sample"
)
```

