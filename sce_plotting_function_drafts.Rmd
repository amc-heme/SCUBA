---
title: "SCE plotting_function_drafts"
output: html_document
date: "2023-02-13"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(Seurat)
library(SingleCellExperiment)
library(DelayedArray)
library(HDF5Array)
library(DelayedMatrixStats)

library(ggplot2)
library(dplyr)

# see sce_object_operations.Rmd for code to generate HDF5-enabled 
# SingleCellExperiment object

# Directory for SingleCellExperiment HDF5 version 
# SCE object is derived from the Cancer Discovery Seurat object
hdf5Dir <-
  "data/sce_hdf5/"

sce <- loadHDF5SummarizedExperiment(dir = hdf5Dir)

sobj <- readRDS("../scExploreR_files/scExploreR/Seurat_Objects/Cancer_discovery_object/pei_cd_20221122.Rds")
```

# UMAP function

The code below is based on the Seurat::DimPlot function, while leaving lower-level functions intact (for now).

The version below is written for SingleCellExperiment objects only. Later, a combined function that accepts both Seurat and SCE objects will be created.

```{r}
# User arguments ####
object <- sce
reduction <- "UMAP"
group_by <- "named_clusters"
shape_by <- NULL#"named_clusters"
split_by <- "sample"
# Test subset (1,40, 56)
cells <- NULL #c("DX_AAACCCAAGCGTATAA","DX_AACAACCGTTAGTTCG", "DX_AACCATGTCTCTATGT")
dims <- c(1, 2)
# Uses same default seed as Seurat::DimPlot to yield comparable results
seed <- 1

cols = NULL
pt_size = NULL
order = NULL
shuffle = FALSE
label = FALSE
label_size = 4
label_color = 'black'
label_box = FALSE
repel = FALSE
cells_highlight = NULL
cols_highlight = '#DE2D26'
sizes_highlight = 1
na_value = 'grey50'
ncol = NULL
combine = TRUE
raster = NULL
raster_dpi = c(512, 512)

#####
# 1. Define reduction (defaults to the first reduction stored for sce objects)
# Uses rlang %||% infix
reduction <- reduction %||% SingleCellExperiment::reducedDimNames(object)[1]
# 2. Define cells to include in plot
## Same as for seurat object ##
cells <- cells %||% BiocGenerics::colnames(object) 

# 3. Fetch dimensional reduction data from object
data <- SingleCellExperiment::reducedDims(object)[[reduction]][cells, dims]
data <- BiocGenerics::as.data.frame(data)

# 4. Fetch names of dimensions to plot
# For SCE objects, use the column names for the requested dim indices
# (there is no `Key()` method for SingleCellExperiment objects)
dim_names <- colnames(data)[dims]

# 5. Process group by selection
# There is no "ident" property for SingleCellExperiment objects, so defaults 
# will be chosen based on the first metadata column, rather than the current ident class
# Store original entry for group_by
orig_groups <- group_by

if (is.null(group_by)){
  warning("group_by is NULL. Defaulting to the first column in colData.")
  group_by <- names(colData(object))[1]
}

# 6. Bind group by metadata to the table of reduction coordinates
data <-
  cbind(
    data,
    # Subsets for selected cells, and the names of entered group_by columns
    colData(object)[cells, group_by, drop = FALSE]
    )

# 7. Define group_by variables to iterate through
group_by_cols <-
  colnames(data)[3:ncol(data)]

# 8. Convert group by columns to factors if they are not already
for (group in group_by_cols) {
  if (!is.factor(data[, group])) {
    data[, group] <- factor(data[, group])
  }
}

# 9. Add shape_by data if it exists
if (!is.null(x = shape_by)) {
  data[, shape_by] <- colData(object)[cells, shape_by, drop = TRUE]
}

# 10. Same for split_by data
if (!is.null(x = split_by)) {
  data[, split_by] <- colData(object)[cells, split_by, drop = TRUE]
}

# 11. If sufffle is TRUE, randomly shuffle cells
if (isTRUE(shuffle)) {
    set.seed(seed = seed)
    data <- data[sample(x = 1:nrow(x = data)), ]
  }

# 12. Create a plot for each group_by variable in group_by_cols
plots <- 
  lapply(
    X = group_by,
    FUN = function(group) {
      plot <- Seurat::SingleDimPlot(
        data = data[, c(dim_names, group, split_by, shape_by)],
        dims = dim_names,
        col.by = group,
        # cols: a categorical pallete in this case
        cols = cols,
        pt.size = pt_size,
        shape.by = shape_by,
        order = order,
        label = FALSE,
        # Cells to highlight
        cells.highlight = cells_highlight,
        cols.highlight = cols_highlight,
        sizes.highlight = sizes_highlight,
        na.value = na_value,
        raster = raster,
        raster.dpi = raster_dpi
      )
      if (label) {
        plot <- Seurat::LabelClusters(
          plot = plot,
          id = group,
          repel = repel,
          size = label_size,
          split.by = split_by,
          box = label_box,
          color = label_color
        )
      }
      if (!is.null(x = split_by)) {
        plot <- 
          plot + 
          Seurat:::FacetTheme() +
          ggplot2::facet_wrap(
            # rlang injection operator
            # ?`!!` for more information
            facets = vars(!!sym(x = split_by)),
            ncol = if (length(x = group_by) > 1 || is.null(x = ncol)) {
              length(x = unique(x = data[, split_by]))
            } else {
              ncol
            }
          )
      }
      plot <- if (is.null(x = orig_groups)) {
        plot + labs(title = NULL)
      } else {
        plot + CenterTitle()
      }
    }
  )
  if (!is.null(x = split_by)) {
    ncol <- 1
  }
  if (combine) {
    plots <- 
      patchwork::wrap_plots(
        plots, 
        # %iff% infix (Seurat package)
        # Uses ncol if orig.groups is not NULL, otherwise uses ncol >:(
        ncol = orig_groups %iff% ncol
        )
  }
 
plots 
#return(plots)
```
```{r}
Seurat::DimPlot(
  object = sobj,
  group.by = "named_clusters",
  split.by = "sample"
)
```




# Seurat code for DimPlot
```{r}
# Seurat code
object <- sobj
group.by <- "named_clusters"
shape.by <- "sample"
reduction <- "umap"

if (length(x = dims) != 2) {
    stop("'dims' must be a two-length vector")
  }
  # Determine reduction to use (if NULL, use default))
  # %||% infix is from rlang
  reduction <- reduction %||% DefaultDimReduc(object = object)
  # Read parameter for cells to plot (defaults to all cells)
  cells <- cells %||% colnames(x = object)
  
  # Fetch data for chosen reduction from object 
  # subset for chosen cells and dims 
  data <- Embeddings(object = object[[reduction]])[cells, dims]
  # Convert to data.frame (default is a matrix)
  data <- as.data.frame(x = data)
  # Form names for dim reduction coordinates on the x- and y- axis
  dims <- 
    paste0(
      # Use the key of the *reduction* chosen by the 
      # user (or the default reduction)
      Key(object = object[[reduction]]), 
      dims
      )
  
  # Store current ident class
  object[['ident']] <- Idents(object = object)
  # Store group by variable in `orig.groups`
  orig.groups <- group.by
  # Define the group by variable, using ident column if undefined
  group.by <- group.by %||% 'ident'
  
  # Add values of the group.by metadata variable(s) for 
  # each cell to the reduction data
  data <- 
    cbind(
      data, 
      object[[group.by]][cells, , drop = FALSE]
      )
  
  # Explicitly define group.by as the column names for each metadata variable
  # added to the reduction matrix above
  group.by <- colnames(x = data)[3:ncol(x = data)]

  # If any of the metadata columns are not factors, coerce them into factors.
  for (group in group.by) {
    if (!is.factor(x = data[, group])) {
      data[, group] <- factor(x = data[, group])
    }
  }
  
  # Add data for shape.by metadata variable if it exists
  if (!is.null(x = shape.by)) {
    data[, shape.by] <- object[[shape.by, drop = TRUE]]
  }
  
  # Same for split.by metadata variable
  if (!is.null(x = split.by)) {
    data[, split.by] <- object[[split.by, drop = TRUE]]
  }
```

# Test SCEPlots::DimPlot

```{r}
sce <- loadHDF5SummarizedExperiment(dir = hdf5Dir)

# SCE object
SCEPlots::DimPlot(
  object = sce,
  reduction = "UMAP",
  group_by = "named_clusters",
  split_by = "sample"
)
```
```{r}
sobj <- readRDS("../scExploreR_files/scExploreR/Seurat_Objects/Cancer_discovery_object/pei_cd_20221122.Rds")

SCEPlots::DimPlot(
  object = sobj,
  reduction = "umap",
  group_by = "named_clusters",
  split_by = "sample"
)
```
# Feature plots

Code from Seurat package

```{r}
object <- sobj
features <- c("BCL2", "HOXA9")

dims = c(1, 2)
cells = NULL
cols = c('lightgrey', 'blue')
# cols = if (blend) {
#   c('lightgrey', '#ff0000', '#00ff00')
# } else {
#   c('lightgrey', 'blue')
# }
pt.size = NULL
order = FALSE
# Cutoffs are NA by default
min.cutoff = NA 
max.cutoff = NA
reduction = NULL
split.by = NULL
keep.scale = "feature"
shape.by = NULL
slot = 'data'
blend = FALSE
blend.threshold = 0.5
label = FALSE
label.size = 4
label.color = "black"
repel = FALSE
ncol = NULL
coord.fixed = FALSE
by.col = TRUE
#sort.cell = NULL,
#interactive = FALSE,
combine = TRUE
raster = NULL
raster.dpi = c(512, 512)

# Check keep.scale param for valid entries
if (!(is.null(x = keep.scale)) && !(keep.scale %in% c("feature", "all"))) {
  stop("`keep.scale` must be set to either `feature`, `all`, or NULL")
}

# Set a theme to remove right-hand Y axis lines
# Also sets right-hand Y axis text label formatting
# (Convert to a function?)
no_right <- theme(
  axis.line.y.right = element_blank(),
  axis.ticks.y.right = element_blank(),
  axis.text.y.right = element_blank(),
  axis.title.y.right = element_text(
    face = "bold",
    size = 14,
    margin = margin(r = 7)
  )
)

# Get the DimReduc to use
reduction <- reduction %||% DefaultDimReduc(object = object)

if (length(x = dims) != 2 || !is.numeric(x = dims)) {
  stop("'dims' must be a two-length integer vector")
}

# If blending is enabled, verify there are exactly two features entered
if (blend && length(x = features) != 2) {
  stop("Blending feature plots only works with two features")
}

# Set color scheme for blended FeaturePlots
if (blend) {
  default.colors <- eval(expr = formals(fun = FeaturePlot)$cols)
  cols <- switch(
    EXPR = as.character(x = length(x = cols)),
    '0' = {
      warning(
        "No colors provided, using default colors",
        call. = FALSE,
        immediate. = TRUE
      )
      default.colors
    },
    '1' = {
      warning(
        "Only one color provided, assuming specified is double-negative and augmenting with default colors",
        call. = FALSE,
        immediate. = TRUE
      )
      c(cols, default.colors[2:3])
    },
    '2' = {
      warning(
        "Only two colors provided, assuming specified are for features and agumenting with '",
        default.colors[1],
        "' for double-negatives",
        call. = FALSE,
        immediate. = TRUE
      )
      c(default.colors[1], cols)
    },
    '3' = cols,
    {
      warning(
        "More than three colors provided, using only first three",
        call. = FALSE,
        immediate. = TRUE
      )
      cols[1:3]
    }
  )
}
if (blend && length(x = cols) != 3) {
  stop("Blending feature plots only works with three colors; first one for negative cells")
}

# Name the reductions
dims <- paste0(Key(object = object[[reduction]]), dims)

# Define cells to be plotted
cells <- cells %||% colnames(x = object)

# Get plotting data (gets reduction data and expression data for the
# feature(s) entered simultaneously)
data <- 
  FetchData(
    object = object,
    vars = c(dims, 'ident', features),
    cells = cells,
    slot = slot
  )

# Check presence of features/dimensions
if (ncol(x = data) < 4) {
  stop(
    "None of the requested features were found: ",
    paste(features, collapse = ', '),
    " in slot ",
    slot,
    call. = FALSE
  )
} else if (!all(dims %in% colnames(x = data))) {
  stop("The dimensions requested were not found", call. = FALSE)
}

# Define feature names using the data matrix
features <- colnames(x = data)[4:ncol(x = data)]

# Determine cutoffs
min.cutoff <- mapply(
  FUN = function(cutoff, feature) {
    print("Cutoff")
    print(cutoff)
    print("feature")
    print(feature)
    
    return(ifelse(
      # For each feature and cutoff, if the cutoff is NULL, use the minimum
      # expression value for the feature. Otherwise, use the supplied
      # cutoff (percentile)
      test = is.na(x = cutoff),
      yes = min(data[, feature]),
      no = cutoff
    ))
  },
  cutoff = min.cutoff,
  feature = features
)

max.cutoff <- mapply(
  FUN = function(cutoff, feature) {
    return(ifelse(
      test = is.na(x = cutoff),
      yes = max(data[, feature]),
      no = cutoff
    ))
  },
  cutoff = max.cutoff,
  feature = features
)

  # Ensure the number of values entered for min.cutoff and max.cutoff equals the
  # number of features
  check.lengths <- unique(x = vapply(
    X = list(features, min.cutoff, max.cutoff),
    FUN = length,
    FUN.VALUE = numeric(length = 1)
  ))
  if (length(x = check.lengths) != 1) {
    stop("There must be the same number of minimum and maximum cuttoffs as there are features")
  }

  # brewer.gran: (appears to apply if an R Color Brewer palette is passed to
  # cols.
  brewer.gran <- ifelse(
    test = length(x = cols) == 1,
    yes = brewer.pal.info[cols, ]$maxcolors,
    no = length(x = cols)
  )

  # Apply cutoffs to data
  data[, 4:ncol(x = data)] <-
    sapply(
      X = 4:ncol(x = data),
      FUN = function(index) {
        data.feature <- as.vector(x = data[, index])
        min.use <-
          Seurat::SetQuantile(cutoff = min.cutoff[index - 3], data.feature)
        max.use <-
          Seurat::SetQuantile(cutoff = max.cutoff[index - 3], data.feature)
        data.feature[data.feature < min.use] <- min.use
        data.feature[data.feature > max.use] <- max.use
        if (brewer.gran == 2) {
          return(data.feature)
        }
        data.cut <- if (all(data.feature == 0)) {
          0
        }
        else {
          as.numeric(x = as.factor(x = cut(
            x = as.numeric(x = data.feature),
            breaks = brewer.gran
          )))
        }
        return(data.cut)
      }
    )
  colnames(x = data)[4:ncol(x = data)] <- features
  rownames(x = data) <- cells

  # Figure out splits (FeatureHeatmap)
  data$split <- if (is.null(x = split.by)) {
    Seurat::RandomName()
  } else {
    switch(
      EXPR = split.by,
      ident = Idents(object = object)[cells, drop = TRUE],
      object[[split.by, drop = TRUE]][cells, drop = TRUE]
    )
  }
  if (!is.factor(x = data$split)) {
    data$split <- factor(x = data$split)
  }
  # Set shaping variable
  if (!is.null(x = shape.by)) {
    data[, shape.by] <- object[[shape.by, drop = TRUE]]
  }
  # Make list of plots
  plots <- vector(
    mode = "list",
    length = ifelse(
      test = blend,
      yes = 4,
      no = length(x = features) * length(x = levels(x = data$split))
    )
  )
  # Apply common limits
  xlims <- c(floor(x = min(data[, dims[1]])), ceiling(x = max(data[, dims[1]])))
  ylims <- c(floor(min(data[, dims[2]])), ceiling(x = max(data[, dims[2]])))
  # Set blended colors
  if (blend) {
    ncol <- 4
    color.matrix <- BlendMatrix(
      two.colors = cols[2:3],
      col.threshold = blend.threshold,
      negative.color = cols[1]
    )
    cols <- cols[2:3]
    colors <- list(
      color.matrix[, 1],
      color.matrix[1, ],
      as.vector(x = color.matrix)
    )
  }
```

## Create version of `FetchData()` for SCE objects
#### Wednesday, February 15th, 2023

FetchData can pull information from both reductions and assays. For now, the SCE equivalent will only pull information from assays (summarized experiments).

NOTE: this is the initial version. For the current draft of the code, see the chunk labeled "FetchData method"

```{r}
# feature_data()
features <- c("ADT_CD90", "ADT_CD3", "RNA_HOXA9") #c("RNA_HOXA9") 
object <- sce
slot <- "logcounts"

feature_data <- function(object, features, cells = NULL, slot = NULL){
  # 1. Set default values
  # Slot (assay): defaults to the first assay stored in the object
  slot <- slot %||% assayNames(object)[1]
  # Cells: if NULL, use all cells in the object
  cells <- cells %||% colnames(object)
  
  # 2. For each feature, fetch data from object for the defined slot
  sapply(
    features,
    function(feature, object, slot){
      # 2.1. Determine the experiment "key" of the feature passed 
      # alphanumeric features to the left of an underscore will be treated as 
      # the key, and will be compared against the main and alternate experiment
      # names.
      exp <- 
        gsub(
          pattern = '(^[[:alnum:]]+)_.*', 
          replacement = "\\1", 
          x = feature, 
          fixed = FALSE
          )
      
      feature_name <- 
        gsub(
          pattern = '^[[:alnum:]]+_(.*)', 
          replacement = "\\1", 
          x = feature, 
          fixed = FALSE
          )
      
      # 2.2. Fetch data for feature from matrix
      # Determine if feature is in the main experiment or an alternate experiment
      if (exp == mainExpName(object)){
        # Determine if the feature name is in the expression matrix under 
        # the defined slot
        if (feature_name %in% rownames(assays(object)[[slot]])){
          # Pull feature row and transpose to column
          assays(object)[[slot]][feature_name, , drop = FALSE] |> 
            as.data.frame() |> 
            t()
        } else {
          # Display message to user if not found
          warning(
            glue::glue(
              "Feature {feature_name} not found in the experiment {mainExpName(object)}."
              )
            )
        }
      } else if (exp %in% altExpNames(object)){
        # Load alternate experiment (also a SingleCellExperiment object)
        alt_exp_data <- altExps(object)[[exp]]
        
        # Determine if the feature name is in the expression matrix under 
        # the defined slot
        if (feature_name %in% rownames(assays(alt_exp_data)[[slot]])){
          assays(alt_exp_data)[[slot]][feature_name, , drop = FALSE] |> 
            as.data.frame() |> 
            t()
        } else {
          # Display message to user if not found
          warning(
            glue::glue(
              "Feature {feature_name} not found in the experiment {mainExpName(alt_exp_data)}."
              )
            )
        }
      } else {
        warning(glue::glue("No experiment found matching the entered key {exp}_ (for {feature})."))
      }
    },
    object,
    slot
  )
}

feature_data(
  object = object,
  features = c("ADT_CD90", "RNA_HOXA9"),
  slot = "logcounts"
  ) |> head()


# What if a feature is entered without a prefix?
feature <- "HOXA9"
exp <- 
  gsub(
    pattern = '(^[[:alnum:]]+)_.*', 
    replacement = "\\1", 
    x = feature, 
    fixed = FALSE
    )

feature_name <- 
  gsub(
    pattern = '^[[:alnum:]]+_(.*)', 
    replacement = "\\1", 
    x = feature, 
    fixed = FALSE
    )
# If this happens, the function mistakenly assumes "HOXA9" is the assay 
# A function is required to test if the feature name passed is in "assay_feature"
# format
grepl("^[[:alnum:]]+_[[:alnum:]]+", "HOXA9")
grepl("^[[:alnum:]]+_[[:alnum:]]+", "RNA_HOXA9")
```

```{r}
output <- 
  SCEPlots::feature_data(
    object = sce,
    features = c("HOXA9", "CD90", "ADT_CD90", "ADT_CD1000")
  )
```

# Seurat::FetchData Code from SeuratObject package

Code is annotated at each major step.

```{r Seurat::FetchData Demo}
object <- sobj
cells <- NULL
# List of test variables
vars <-
  # Keyed features
  c("adt_CD117", 
    "adt_CD11b",
    "rna_HOXA9", 
    # Nonexistent features
    "adt_CD900",
    # Metadata
    "nCount_RNA", 
    "nFeature_RNA", 
    # "Ambiguous" feature not in RNA assay
    "CD90",
    "CD56",
    "CD3")
slot <- "data"

# Seurat FetchData function
object <- UpdateSlots(object = object)
cells <- cells %||% colnames(x = object)
if (is.numeric(x = cells)) {
  cells <- colnames(x = object)[cells]
}
if (is.null(x = vars)) {
  df <- EmptyDF(n = length(x = cells))
  rownames(x = df) <- cells
  return(df)
}

# Get a list of all objects to search through and their keys
# object.keys includes keys for each assay and projection
object.keys <- Key(object = object)
# Find all vars that are keyed
# at this stage, keyed.vars will be the indexes of requested features that map 
# to each *key* in the object (each *assay or reduction*). If a key does not 
# have any variables mapped to it it will be an integer of length zero.
keyed.vars <- lapply(
  X = object.keys,
  FUN = function(key) {
    if (length(x = key) == 0 || nchar(x = key) == 0) {
      return(integer(length = 0L))
    }
    return(grep(pattern = paste0('^', key), x = vars))
  }
)

keyed.vars <- Filter(f = length, x = keyed.vars)

# Determine if features requested are part of spatial transcriptomics assays
ret.spatial2 <- 
  vapply(
    X = names(x = keyed.vars),
    FUN = function(x) {
      return(inherits(x = object[[x]], what = 'FOV'))
    },
    FUN.VALUE = logical(length = 1L)
  )

if (any(ret.spatial2) && !all(ret.spatial2)) {
  warning(
    "Data returned from spatial coordinates are incompatible with other data, returning only spatial coordinates",
    call. = FALSE,
    immediate. = TRUE
  )
  keyed.vars <- keyed.vars[ret.spatial2]
}

# Generate list of data from variables mapped to keys
# Data structure returned is a list of lists
data.fetched <- lapply(
  # This iterates through each assay/reuction
  X = names(x = keyed.vars),
  FUN = function(x) {
    vars.use <- vars[keyed.vars[[x]]]
    key.use <- object.keys[x]
    # Get data for each var in the current assay
    data.return <- 
      # Procedure for fetching data depends on the class of the current assay/reduction
      if (inherits(x = object[[x]], what = 'DimReduc')) {
        tryCatch(
          expr = FetchData(object = object[[x]], vars = vars.use, cells = cells),
          error = function(e) {
            return(NULL)
          }
        )
    } else if (inherits(x = object[[x]], what = 'Assay')) {
      vars.use <- gsub(pattern = paste0('^', key.use), replacement = '', x = vars.use)
      data.assay <- GetAssayData(
        object = object,
        slot = slot,
        assay = x
      )
      
      print("Class of data_assay")
      print(class(data.assay))
      # Check to see if vars in vars.use are in the rownames of the assay first
      # (this keeps errors from occurring when vars that are not features from 
      # this assay start with what appears to be the assay key, for example 
      # if there is a metadata variable named 'rna_mitochondrial_percentage"
      # and an RNA assay)
      vars.use <- vars.use[vars.use %in% rownames(x = data.assay)]
      data.vars <- t(x = as.matrix(data.assay[vars.use, cells, drop = FALSE]))
      
      print("data.vars after fetching variables")
      print(str(data.vars))
      print(class(data.vars))
      if (ncol(data.vars) > 0) {
        colnames(x = data.vars) <- paste0(key.use, vars.use)
      }
      data.vars
    } else if (inherits(x = object[[x]], what = 'FOV')) {
      vars.use <- gsub(pattern = paste0('^', key.use), replacement = '', x = vars.use)
      FetchData(object = object[[x]], vars = vars.use, cells = cells)
    } else if (inherits(x = object[[x]], what = 'SpatialImage')) {
      vars.unkeyed <- gsub(pattern = paste0('^', key.use), replacement = '', x = vars.use)
      names(x = vars.use) <- vars.unkeyed
      coords <- GetTissueCoordinates(object = object[[x]])[cells, vars.unkeyed, drop = FALSE]
      colnames(x = coords) <- vars.use[colnames(x = coords)]
      coords
    }
    
    data.return <- as.list(x = as.data.frame(x = data.return))
    return(data.return)
  }
)

print("Before unlisting")
print(str(data.fetched))
# Removes the main list structure, but retains the list of expression values 
# returned for each variable found (via recursive = FALSE)
data.fetched <-
  unlist(x = data.fetched, recursive = FALSE)
  
print("After unlisting")
print(str(data.fetched))

if (any(ret.spatial2)) {
  return(as.data.frame(x = data.fetched))
}

# Pull vars from object metadata
# Identify metadata variables
# Test if variables that have not already been fetched are metadata variables
meta.vars <- 
  vars[vars %in% colnames(x = object[[]]) & !(vars %in% names(x = data.fetched))]

# Add metadata variables requested to the list of data fetched
# Data.frame extracted will be coerced to a list
print("Class of object with metdata variables selected")
print(class(object[[meta.vars]]))
print("Class of data.fetched")
print(class(data.fetched))
data.fetched <- c(data.fetched, object[[meta.vars]][cells, , drop = FALSE])

# Check if any metadata variables entered are also in the default assay
# (possible source of ambiguity)
meta.default <- 
  meta.vars[meta.vars %in% rownames(x = GetAssayData(object = object, slot = slot))]
if (length(x = meta.default)) {
  warning(
    "The following variables were found in both object metadata and the default assay: ",
    paste0(meta.default, collapse = ", "),
    "\nReturning metadata; if you want the feature, please use the assay's key (eg. ",
    paste0(Key(object = object[[DefaultAssay(object = object)]]), meta.default[1]),
    ")",
    call. = FALSE
  )
}

# Pull vars that are in the default assay, and are not already fetched
default.vars <- 
  vars[vars %in% rownames(x = GetAssayData(object = object, slot = slot)) & !(vars %in% names(x = data.fetched))]

# Attempt to subset the matrix for `slot` in the default assay for the variable
data.fetched <- c(
  data.fetched,
  tryCatch(
    expr = 
      as.data.frame(
        x = 
          t(
            x = as.matrix(
              x = GetAssayData(
                object = object,
                slot = slot
                )[default.vars, cells, drop = FALSE]
              )
            )
        ),
    error = function(...) {
      # If the variable is not present in the matrix, an error will be returned.
      # Return NULL in this case, which will leave data.fetched unchanged.
      return(NULL)
    }
  )
)

# Pull identities if "ident" is passed to `vars`
if ('ident' %in% vars && !'ident' %in% colnames(x = object[[]])) {
  data.fetched[['ident']] <- Idents(object = object)[cells]
}

# Try to find ambiguous vars (those not yet found with above methods)
fetched <- names(x = data.fetched)
vars.missing <- setdiff(x = vars, y = fetched)

if (length(x = vars.missing) > 0) {
  # Search in alternative assays for variables not found in the main assay
  # or metadata
  # vars.alt: an empty list with a length equal to the number of variables not 
  # yet found
  vars.alt <- vector(mode = 'list', length = length(x = vars.missing))
  names(x = vars.alt) <- vars.missing
  
  # Loop constructs a list of the assays each remaining feature was found in
  for (assay in FilterObjects(object = object, classes.keep = 'Assay')) {
    cat(paste0("Assay:", assay, "\n"))
    # Store which features from vars.missing are in the current assay
    vars.assay <- Filter(
      f = function(x) {
        features.assay <- 
          rownames(
            x = GetAssayData(
              object = object,
              assay = assay,
              slot = slot
              )
            )
        return(x %in% features.assay)
      },
      x = vars.missing
    )
    
    print("vars.assay")
    print(vars.assay)
    
    # For each variable found in this assay, append the assay name to the
    # feature's entry in vars.alt.
    for (var in vars.assay) {
      vars.alt[[var]] <- 
        append(x = vars.alt[[var]], values = assay)
    }
  }
  
  print("vars.alt")
  print(vars.alt)
  
  # Message for variables found in multiple alternative assays
  vars.many <- names(x = Filter(
    f = function(x) {
      # (Those with more than one assay entry in the list) 
      return(length(x = x) > 1)
    },
    x = vars.alt
  ))
  if (length(x = vars.many) > 0) {
    warning(
      "Found the following features in more than one assay, excluding the default. We will not include these in the final data frame: ",
      paste(vars.many, collapse = ', '),
      call. = FALSE,
      immediate. = TRUE
    )
  }
  
  # Store variables that have not been found in any assays
  vars.missing <- names(x = Filter(
    f = function(x) {
      return(length(x = x) != 1)
    },
    x = vars.alt
  ))
  
  # Pull vars found in only one alternative assay and return message
  vars.alt <- Filter(
    f = function(x) {
      return(length(x = x) == 1)
    },
    x = vars.alt
  )
  
  for (var in names(x = vars.alt)) {
    assay <- vars.alt[[var]]
    warning(
      'Could not find ',
      var,
      ' in the default search locations, found in ',
      assay,
      ' assay instead',
      immediate. = TRUE,
      call. = FALSE
    )
    keyed.var <- paste0(Key(object = object[[assay]]), var)
    data.fetched[[keyed.var]] <- as.vector(
      x = GetAssayData(object = object, assay = assay, slot = slot)[var, cells]
    )
    vars <- sub(
      pattern = paste0('^', var, '$'),
      replacement = keyed.var,
      x = vars
    )
  }
  fetched <- names(x = data.fetched)
}

# Name the vars not found in a warning (or error if none of the vars 
# entered were found)
m2 <- if (length(x = vars.missing) > 10) {
  paste0(' (10 out of ', length(x = vars.missing), ' shown)')
} else {
  ''
}
if (length(x = vars.missing) == length(x = vars)) {
  stop(
    "None of the requested variables were found",
    m2,
    ': ',
    paste(head(x = vars.missing, n = 10L), collapse = ', ')
  )
} else if (length(x = vars.missing) > 0) {
  warning(
    "The following requested variables were not found",
    m2,
    ': ',
    paste(head(x = vars.missing, n = 10L), collapse = ', ')
  )
}

# Assembled fetched vars in a data frame
data.fetched <- as.data.frame(
  x = data.fetched,
  row.names = cells,
  stringsAsFactors = FALSE
)

print("Fetched data")
#print(head(data.fetched))
print(colnames(data.fetched))

# Order data to return in the same order it was entered in vars, instead of the
# order the data was fetched.
data.order <- 
  na.omit(
    object = 
      pmatch(
        x = vars,
        # `fetched`: vector of variables for which data was found
        table = fetched
        )
    )

print("data.order")
print(data.order)

if (length(x = data.order) > 1) {
  data.fetched <- data.fetched[, data.order]
}

print("Fetched data after ordering")
#print(head(data.fetched))
print(colnames(data.fetched))

# Add column names to data.frame 
colnames(x = data.fetched) <- vars[vars %in% fetched]
return(data.fetched)
```

# Code for FetchData Method
Thursday, February 16th
Monday, February 21st
Thursday, March 9th, 2023

Revisiting function code to handle features not found.

```{r Fetchdata Method}
object <- sce
# Test set
vars <-
  # Keyed features
  c("ADT_CD117",
    "RNA_HOXA9",
    # Nonexistent features
    "ADT_CD900",
    "RNA_mito_pct",
    # Metadata
    "nCount_RNA",
    "nFeature_RNA",
    # Feature in RNA assay/experiment specified without a key
    "HDAC5",
    # "Ambiguous" feature not in RNA assay
    "CD90", 
    "CD56", 
    "CD3")
slot = "logcounts"
cells = NULL


# 1. Set default values
# Slot (assay): defaults to the first assay stored in the object
slot <- slot %||% assayNames(object)[1]
# Cells: if NULL, use all cells in the object
cells <- cells %||% colnames(object)

# 2. Identify which experiments have keyed features requested for them
# Experiments will be looped through, instead of looping through each var to
# find an associated experiment

# Get a list of all experiment "keys" in the object
exp_names <- c(mainExpName(object), altExpNames(object))

# Construct a list of experiments with the indices of vars that match
# each experiment
keyed_vars <-
  lapply(
    exp_names,
    function(exp){
      # grep returns the indices of matching vars
      grep(pattern = paste0('^', exp), x = vars)
    }
  )

names(keyed_vars) <- exp_names

# Subset list for experiments that have at least one matching var
keyed_vars <-
  Filter(
    # Filter list for elements with any length
    f = length,
    x = keyed_vars
  )

# 3. Loop through experiment and get data for the keyed vars in that experiment
fetched_data <-
  lapply(
    names(keyed_vars),
    function(exp){
      # Variables in current experiment
      exp_vars <- vars[keyed_vars[[exp]]]

      # Remove experiment key for feature retrieval
      keyless_vars <-
        gsub(
          pattern = paste0('^', exp, '_(.*)'),
          replacement = "\\1",
          x = exp_vars,
          fixed = FALSE
        )

      # Retrieve data
      if (exp == mainExpName(object)){
        # For main experiment
        # Subset to variables that are included in the experiment, to avoid errors
        keyless_vars <- keyless_vars[keyless_vars %in% rownames(object)]
        data <-
          assays(object)[[slot]][keyless_vars, cells, drop = FALSE] |>
          # Must be a matrix for feature names to properly display as names in
          # the final list
          # (begins as a DelayedArray)
          as.matrix() |>
          t()

        # Add experiment key back in
        colnames(data) <- paste0(exp, "_", keyless_vars)
      } else {
        # For alternate experimnent(s)
        # Switch to SingleCellExperiment object for the alternate experiment
        alt_sce <- altExps(object)[[exp]]

        keyless_vars <- keyless_vars[keyless_vars %in% rownames(alt_sce)]

        data <-
          assays(alt_sce)[[slot]][keyless_vars, cells, drop = FALSE] |>
          as.matrix() |>
          t()

        print("as.list on data")
        print(str(data))
        print(str(as.list(as.data.frame(data))))

        # Add experiment key back in
        colnames(data) <- paste0(exp, "_", keyless_vars)
      }

      # Return as a list
      data <- as.list(as.data.frame(data))
      data
    }
  )

# Nested list is returned, condense to a list (only unlist at the top level)
fetched_data <- unlist(fetched_data, recursive = FALSE)

str(fetched_data)

# 4. Fetch metadata variables
# Identify metadata variables
remaining_vars <- vars[!vars %in% names(fetched_data)]
metadata_vars <- remaining_vars[remaining_vars %in% names(colData(object))]

# Fetch metadata vars and append to fetched_data
fetched_data <-
  c(
    fetched_data,
    # SeuratObjects return metadata as a data.frame by default. This must be
    # done manually to properly append to fetched_data (data.frames can be
    # coerced to a list)
    as.data.frame(colData(object))[cells, metadata_vars, drop = FALSE]
  )

# Handle ambiguous case of metadata variables also existing in the
# main experiment (warn users that only metadata will be returned)
ambiguous_meta_vars <- metadata_vars[metadata_vars %in% rownames(object)]
if (length(ambiguous_meta_vars) > 0){
  warning(
    "The following variables were found in both object metadata and the main experiment: ",
    paste0(ambiguous_meta_vars, collapse = ", "),
    '\nOnly the metadata will be returned. To get feature data from the main experiment, please add the "key" of the main experiment to the feature (eg. ',
    paste0(mainExpName(object), "_", ambiguous_meta_vars[1]),
    ")",
    call. = FALSE
  )
}

# 5. Fetch data for vars in the main experiment that were not specified
# with an assay key
remaining_vars <- vars[!vars %in% names(fetched_data)]
main_exp_vars <- remaining_vars[remaining_vars %in% rownames(object)]

# Pull vars from main experiment
main_exp_data <-
  assays(object)[[slot]][main_exp_vars, cells, drop = FALSE] |>
  as.matrix() |>
  t()

# Explicitly specify feature names as column names
colnames(main_exp_data) <- main_exp_vars

main_exp_data <-
  main_exp_data |>
  as.data.frame() |>
  as.list()

# Append data to the list of fetched data
fetched_data <-
  c(
    fetched_data,
    main_exp_data
  )

# 6. Handle variables that have not yet been fetched
missing_vars <- vars[!vars %in% names(fetched_data)]

if (length(missing_vars) > 0){
  # 6.1. Create a list to store the experiment(s) each missing feature is in
  # Empty list for storing data
  where_missing_vars <- vector(mode = 'list', length = length(missing_vars))
  names(where_missing_vars) <- missing_vars

  for (exp in altExpNames(object)){
    alt_sce <- altExps(object)[[exp]]

    # Determine which of the missing vars are in the current exp., if any
    missing_in_exp <-
      missing_vars[missing_vars %in% rownames(assays(alt_sce)[[slot]])]

    # For each variable found in this experiment, append the assay name to the
    # feature's entry in missing_in_exp (each entry is a vector)
    for (var in missing_in_exp){
      where_missing_vars[[var]] <-
        append(
          where_missing_vars[[var]],
          values = exp
        )
    }
  }

  # 6.2. Warn user if there are vars in multiple experiments. Do not pull data
  # in this case
  vars_multi_exp <-
    # Subset list from 6.1. for vars with more than one associated experiment
    Filter(
      f = function(x) {
        length(x) > 1
      },
      where_missing_vars
    ) |>
    names()

  
  if (length(vars_multi_exp) > 0){
    warning(
      "The following features were found in more than one alternate experiment. These features will not be included in the data returned: ",
      paste(vars_multi_exp, collapse = ', '),
      ". \n",
      "To include these features, please specify which experiment you would like to pull data from using the experiment name and an underscore (i.e. ",
      # Display an example with the experiment key added (using an exp that
      # the example is certain to be in)
      paste0(where_missing_vars[[vars_multi_exp[1]]][1], "_", vars_multi_exp[1]),
      ").",
      call. = FALSE,
      immediate. = TRUE
    )
  }
  
  # 6.3. Pull data for missing variables found in one alternate experiment
  # Update list of missing vars to exclude vars in one experiment
  missing_vars <-
    Filter(
      f = function(x){
        length(x) != 1
      },
      where_missing_vars
    ) |>
    names()

  # Subset missing vars for vars in one exp
  where_missing_vars <-
    Filter(
      f = function(x) {
        length(x) == 1
      },
      where_missing_vars
    )

  #
  for (var in names(where_missing_vars)){
    exp <- where_missing_vars[[var]]
    # Load alternate experiment
    alt_sce <- altExps(object)[[exp]]

    data <-
      assays(alt_sce)[[slot]][var, cells, drop = FALSE] |>
      # Only one var will be fetched at once in this case, so data can be added
      # as a vector to the list of fetched data
      as.vector()

    # Add experiment key to var
    keyed_var <- paste0(exp, "_", var)

    fetched_data[[keyed_var]] <- data

    # Edit vars to use the keyed var
    vars <-
      sub(
        pattern = paste0('^', var, '$'),
        replacement = keyed_var,
        x = vars
      )
  }
}

# 7. User warnings/errors
ten_plus_message <-
  if (length(x = missing_vars) > 10) {
    paste0(' (10 out of ', length(x = missing_vars), ' shown)')
  } else {
    ''
  }

if (length(x = missing_vars) == length(x = vars)) {
  stop(
    "None of the requested variables were found",
    ten_plus_message,
    ': ',
    paste(head(x = missing_vars, n = 10L), collapse = ', ')
  )
} else if (length(x = missing_vars) > 0) {
  warning(
    "The following requested variables were not found",
    ten_plus_message,
    ': ',
    paste(head(x = missing_vars, n = 10L), collapse = ', ')
  )
}

# 8. Construct data.frame and return to user
# Store names of vars fetched for downstream operations
fetched_vars <- names(fetched_data)

# Convert fetched_data to data.frame
fetched_data <-
  as.data.frame(
    fetched_data,
    row.names = cells,
    stringsAsFactors = FALSE
  )

print("fetched_data")
print(str(fetched_data))

# Re-order vars to reflect the order entered, instead of the order fetched
data_order <-
  na.omit(
    object =
      pmatch(
        x = vars,
        table = fetched_vars
      )
  )

if (length(x = data_order) > 1) {
  fetched_data <- fetched_data[, data_order]
}

# Change column names to reflect `vars` that were fetched
colnames(x = fetched_data) <- vars[vars %in% fetched_data]

print("fetched_data after ordering")
print(str(fetched_data))

#fetched_data


# ------------------------------------------------------------------------------
# For each feature, fetch data from object for the defined slot
# Set up features_found to record features for which data has been 
# successfully accessed
# features_found <- c()
# 
# data <-
#   lapply(
#     features,
#     function(feature, object, slot, features_found){
#       # 2.1. Determine the experiment "key" of the feature passed
#       # alphanumeric features to the left of an underscore will be treated as
#       # the key, and will be compared against the main and alternate experiment
#       # names.
# 
#       # Determine if the the entry is in "{experiment}_{feature}" format
#       if (grepl("^[[:alnum:]]+_.*", feature)){
#         # If so, extract experiment name from the assay
#         exp <-
#           gsub(
#             pattern = '(^[[:alnum:]]+)_.*',
#             replacement = "\\1",
#             x = feature,
#             fixed = FALSE
#             )
#         # Feature_name: the name of the feature with the experiment prefix
#         # removed. Used when searching the indicated experiment for the feature.
#         feature_name <-
#           gsub(
#             pattern = '^[[:alnum:]]+_(.*)',
#             replacement = "\\1",
#             x = feature,
#             fixed = FALSE
#             )
#       } else {
#         # If not, search for the feature within the main experiment
#         exp <- mainExpName(object)
#         feature_name <- feature
#       }
# 
#       # 2.2. Fetch data for feature from matrix
#       # Determine if feature is in the main experiment or an alternate experiment
#       if (exp == mainExpName(object)){
#         # Determine if the feature name is in the expression matrix under
#         # the defined slot
#         if (feature_name %in% rownames(assays(object)[[slot]])){
#           # Add feature to the list of features found (use the name of the 
#           # feature as entered, with the prefix if included)
#           features_found <- c(features_found, feature)
#           
#           # Pull feature row and transpose to column
#           assays(object)[[slot]][feature_name, , drop = TRUE] #|>
#             # as.data.frame() |>
#             # t()
#         } else {
#           # Display message to user if not found, and return nothing
#           warning(
#             glue::glue(
#               "Feature {feature_name} not found in the experiment {mainExpName(object)}."
#             )
#           )
# 
#           NULL
#         }
#       } else if (exp %in% altExpNames(object)){
#         # Load alternate experiment (also a SingleCellExperiment object)
#         alt_exp_data <- altExps(object)[[exp]]
# 
#         # Determine if the feature name is in the expression matrix under
#         # the defined slot
#         if (feature_name %in% rownames(assays(alt_exp_data)[[slot]])){
#           # Add feature to the list of features found (use the name of the 
#           # feature as entered, with the prefix if included)
#           features_found <- c(features_found, feature)
#           
#           assays(alt_exp_data)[[slot]][feature_name, , drop = TRUE] #|>
#             #as.data.frame() |>
#             #t()
#         } else {
#           # Display message to user if not found, and return nothing
#           warning(
#             glue::glue(
#               "Feature {feature_name} not found in the experiment {mainExpName(alt_exp_data)}."
#             )
#           )
# 
#           NULL
#         }
#       } else {
#         warning(glue::glue("No experiment found matching the entered key {exp}_ (for {feature})."))
# 
#         NULL
#       }
#     },
#     object,
#     slot,
#     features_found
#   )
# 
# # Apply feature names to list
# names(data) <- features
# 
# # Subset list for features for which information was accessed
# #data[features_found]
# 
# str(data)
# 
# #as.data.frame(data)
# #data
```


# Writing tests for FetchData method

Scripts below are based on Seurat FetchData results and will be used to test the SingleCellExperiment equivalent

```{r}
# Test A: keyed features are pulled from the correct assay
expected_table <- 
  FetchData(
    sobj,
    vars = 
      c("adt_CD117", 
        "rna_HOXA9", 
        # Nonexistent features
        "adt_CD900",
        # Metadata
        "nCount_RNA", 
        "nFeature_RNA", 
        # "Ambiguous" feature not in RNA assay
        "CD90"
        )
    )

# Expect 5 columns
ncol(expected_table) 

# Column sums of expected table
colSums(expected_table)
# Don't forget to use ignore_attr = TRUE when designing the expect statement 
```

# Testing FetchData.SingleCellExperiment

```{r}
FetchData(
    sce,
    slot = "logcounts",
    vars = 
      c("ADT_CD117", 
        "RNA_HOXA9", 
        # Nonexistent features
        "ADT_CD900",
        # Metadata
        "nCount_RNA", 
        "nFeature_RNA", 
        # "Ambiguous" feature not in RNA assay
        "CD90"
        )
    ) |> str()
```

# SCE method issue
## Tuesday, March 21st, 2023

If the script below is ran after starting a new R session, it is observed that the FetchData method works for singlecellexperiment classes regardless of whether SCEPlots is loaded.

```{r}
library(HDF5Array)

sce <- loadHDF5SummarizedExperiment(dir = "data/sce_hdf5/")

FetchData(
  sce,
  vars = "HOXA9"
  ) |> 
  str()

library(Seurat)

FetchData(
  sce,
  vars = "HOXA9"
  ) |> 
  str() 

DimPlot(
  sce,
  group.by = "clusters"
)

library(SCEPlots)

FetchData(
  sce,
  vars = "HOXA9"
  ) |> 
  str()

DimPlot(
  sce,
  group.by = "clusters"
)
```


# Testing speed of DimPlot function relative to Seurat implementation on the full AML object

The test below compares the time elapsed for 100 trials of a) SCEPlots::DimPlot ran on the full AML Seurat object, b) SCEPlots::DimPlot ran on the full AML SingleCellExperiment object, and c) Seurat::DimPlot ran on the full AML Seurat object.

```{r}
library(HDF5Array)

sobj <- readRDS("../scExploreR_files/Testing/Full_AML_Downsampled/full_combined_20230207v1_annotated_sig_1k_v2.Rds")
sce <- loadHDF5SummarizedExperiment("../scExploreR_files/Testing/Full_AML_Downsampled/full_combined_20230207v1_sce/")
```


Original SCEPlots::DimPlot function 
```{r}
#------- Function copied and adapted from Seurat package -----------------------
# https://github.com/satijalab/seurat

#' Dimensional reduction plot
#'
#' Graphs the output of a dimensional reduction technique on a 2D scatter plot where each point is a
#' cell and it's positioned based on the cell embeddings determined by the reduction technique. The function accepts both Seurat and SingleCellExperiment objects.
#' For Seurat objects, cells are colored by their identity class by default, and for
#' SingleCellExperiment objects, cells are colored by the first metadata column in
#' colData(). The metadata variable used for coloring cells can be changed with the group_by parameter).
#'
#' The code for this function was from the {\link[Seurat Package]{https://github.com/satijalab/seurat/blob/master/R/visualization.R}} and adapted for use with
#' {\link[SingleCellExperiment]{https://www.bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html}} objects.
#'
#' @param object  a Seurat object or a SingleCellExperiment object
#' @param dims Dimensions to plot, must be a two-length numeric vector specifying x- and y-dimensions i.e. c(1,2) to plot the first and second dimensions from the
#' reduction results.
#' @param cells Vector of cells to plot (default is all cells)
#' @param cols Vector of colors, each color corresponds to an identity class. This may also be a single character
#' or numeric value corresponding to a palette as specified by \code{\link[RColorBrewer]{brewer.pal.info}}.
#' By default, ggplot2 assigns colors. We also include a number of palettes from the pals package.
#' See \code{\link{DiscretePalette}} for details.
#' @param pt_size Adjust point size for plotting
#' @param reduction Which dimensionality reduction to use. If not specified, first searches for umap, then tsne, then pca
#' @param group_by Name of one or more metadata columns to group (color) cells by
#' (for example, orig.ident); pass 'ident' to group by identity class
#' @param split_by Name of a metadata column to split plot by;
#' see \code{\link{FetchData}} for more details
#' @param shape_by If NULL, all points are circles (default). You can specify any
#' cell attribute (that can be pulled with FetchData) allowing for both
#' different colors and different shapes on cells.  Only applicable if \code{raster = FALSE}.
#' @param order Specify the order of plotting for the idents. This can be
#' useful for crowded plots if points of interest are being buried. Provide
#' either a full list of valid idents or a subset to be plotted last (on top)
#' @param shuffle Whether to randomly shuffle the order of points. This can be
#' useful for crowded plots if points of interest are being buried. (default is FALSE)
#' @param seed Sets the seed if randomly shuffling the order of points.
#' @param label Whether to label the clusters
#' @param label_size Sets size of labels
#' @param label_color Sets the color of the label text
#' @param label_box Whether to put a box around the label text (geom_text vs
#' geom_label)
#' @param repel Repel labels
#' @param cells_highlight A list of character or numeric vectors of cells to
#' highlight. If only one group of cells desired, can simply
#' pass a vector instead of a list. If set, colors selected cells to the color(s)
#' in \code{cols_highlight} and other cells black (white if dark.theme = TRUE);
#' will also resize to the size(s) passed to \code{sizes_highlight}
#' @param cols_highlight A vector of colors to highlight the cells as; will
#' repeat to the length groups in cells_highlight
#' @param sizes_highlight Size of highlighted cells; will repeat to the length
#' groups in cells_highlight
#' @param na_value Color value for NA points when using custom scale
#' @param ncol Number of columns for display when combining plots
#' @param combine Combine plots into a single \code{\link[patchwork]{patchwork}ed}
#' ggplot object. If \code{FALSE}, return a list of ggplot objects
#' @param raster Convert points to raster format, default is \code{NULL} which
#' automatically rasterizes if plotting more than 100,000 cells
#' @param raster_dpi Pixel resolution for rasterized plots, passed to geom_scattermore().
#' Default is c(512, 512).
#'
#' @return A \code{\link[patchwork]{patchwork}ed} ggplot object if
#' \code{combine = TRUE}; otherwise, a list of ggplot objects
#'
DimPlot_orig <- function(
    object,
    dims = c(1, 2),
    cells = NULL,
    cols = NULL,
    pt_size = NULL,
    reduction = NULL,
    group_by = NULL,
    split_by = NULL,
    shape_by = NULL,
    order = NULL,
    shuffle = FALSE,
    seed = 1,
    label = FALSE,
    label_size = 4,
    label_color = 'black',
    label_box = FALSE,
    repel = FALSE,
    cells_highlight = NULL,
    cols_highlight = '#DE2D26',
    sizes_highlight = 1,
    na_value = 'grey50',
    ncol = NULL,
    combine = TRUE,
    raster = NULL,
    raster_dpi = c(512, 512)
) {
  if (length(x = dims) != 2) {
    stop("'dims' must be a two-length vector")
  }

  # Compile data for plotting: methods depend on object type
  if (is(object, "SingleCellExperiment")){
    # For SingleCellExperiment objects
    # 1. Define reduction (defaults to the first reduction stored for sce objects)
    # Uses rlang %||% infix
    reduction <- reduction %||% SingleCellExperiment::reducedDimNames(object)[1]
    # 2. Define cells to include in plot
    ## Same as for seurat object ##
    cells <- cells %||% BiocGenerics::colnames(object)

    # 3. Fetch dimensional reduction data from object
    data <- SingleCellExperiment::reducedDims(object)[[reduction]][cells, dims]
    data <- BiocGenerics::as.data.frame(data)

    # 4. Fetch names of dimensions to plot
    # For SCE objects, use the column names for the requested dim indices
    # (there is no `Key()` method for SingleCellExperiment objects)
    dim_names <- colnames(data)[dims]

    # 5. Process group by selection
    # There is no "ident" property for SingleCellExperiment objects, so defaults
    # will be chosen based on the first metadata column, rather than the current ident class
    # Store original entry for group_by
    orig_groups <- group_by

    if (is.null(group_by)){
      stop("group_by must not be NULL for SingleCellExperiment objects.")
    }

    # 6. Bind group by metadata to the table of reduction coordinates
    data <-
      cbind(
        data,
        # Subsets for selected cells, and the names of entered group_by columns
        colData(object)[cells, group_by, drop = FALSE]
      )

    # 7. Define group_by variables to iterate through
    group_by_cols <-
      colnames(data)[3:ncol(data)]

    # 8. Convert group by columns to factors if they are not already
    for (group in group_by_cols) {
      if (!is.factor(data[, group])) {
        data[, group] <- factor(data[, group])
      }
    }

    # 9. Add shape_by data if it exists
    if (!is.null(x = shape_by)) {
      data[, shape_by] <- colData(object)[cells, shape_by, drop = TRUE]
    }

    # 10. Same for split_by data
    if (!is.null(x = split_by)) {
      data[, split_by] <- colData(object)[cells, split_by, drop = TRUE]
    }

    # 11. If sufffle is TRUE, randomly shuffle cells
    if (isTRUE(shuffle)) {
      set.seed(seed = seed)
      data <- data[sample(x = 1:nrow(x = data)), ]
    }
  } else if (is(object, "Seurat")){
    # For Seurat Objects
    # Determine reduction to use (if NULL, use default))
    # %||% infix is from rlang
    reduction <- reduction %||% DefaultDimReduc(object = object)
    # Read parameter for cells to plot (defaults to all cells)
    cells <- cells %||% colnames(x = object)

    # Fetch data for chosen reduction from object
    # subset for chosen cells and dims
    data <- Embeddings(object = object[[reduction]])[cells, dims]
    # Convert to data.frame (default is a matrix)
    data <- as.data.frame(x = data)
    # Form names for dim reduction coordinates on the x- and y- axis
    dim_names <-
      paste0(
        # Use the key of the *reduction* chosen by the
        # user (or the default reduction)
        Key(object = object[[reduction]]),
        dims
      )

    # Set group by to the current ident class if it is NULL
    # Store current ident class
    object[['ident']] <- Idents(object = object)
    # Store group by variable in `orig_groups`
    orig_groups <- group_by
    group_by <- group_by %||% 'ident'

    # Add values of the group_by metadata variable(s) for
    # each cell to the reduction data
    data <-
      cbind(
        data,
        object[[group_by]][cells, , drop = FALSE]
      )

    # Explicitly define group_by as the column names for each metadata variable
    # added to the reduction matrix above
    group_by_cols <- colnames(x = data)[3:ncol(x = data)]

    # If any of the metadata columns are not factors, coerce them into factors.
    for (group in group_by) {
      if (!is.factor(x = data[, group])) {
        data[, group] <- factor(x = data[, group])
      }
    }

    # Add data for shape_by metadata variable if it exists
    if (!is.null(x = shape_by)) {
      data[, shape_by] <- object[[shape_by, drop = TRUE]]
    }

    # Same for split_by metadata variable
    if (!is.null(x = split_by)) {
      data[, split_by] <- object[[split_by, drop = TRUE]]
    }

    # Randomly shuffle cells if specified by the user
    if (isTRUE(x = shuffle)) {
      set.seed(seed = seed)
      data <- data[sample(x = 1:nrow(x = data)), ]
    }
  } else {
    # Throw an error for unsupported data types
    stop("Object entered is not a SinglecellExperiment or a Seurat object.")
  }

  # For each group by variable, create a DimPlot of cells grouped by that variable.
  plots <- lapply(
    X = group_by_cols,
    FUN = function(group) {
      plot <- Seurat::SingleDimPlot(
        data = data[, c(dim_names, group, split_by, shape_by)],
        dims = dim_names,
        col.by = group,
        # cols: a categorical pallete in this case
        cols = cols,
        pt.size = pt_size,
        shape.by = shape_by,
        order = order,
        label = FALSE,
        # Cells to highlight
        cells.highlight = cells_highlight,
        cols.highlight = cols_highlight,
        sizes.highlight = sizes_highlight,
        na.value = na_value,
        raster = raster,
        raster.dpi = raster_dpi
      )
      if (label) {
        plot <-
          Seurat::LabelClusters(
            plot = plot,
            id = group,
            repel = repel,
            size = label_size,
            split.by = split_by,
            box = label_box,
            color = label_color
          )
      }
      if (!is.null(x = split_by)) {
        plot <-
          plot +
          Seurat:::FacetTheme() +
          ggplot2::facet_wrap(
            # rlang injection operator
            # ?`!!` for more information
            facets = vars(!!sym(x = split_by)),
            ncol = if (length(x = group_by) > 1 || is.null(x = ncol)) {
              length(x = unique(x = data[, split_by]))
            } else {
              ncol
            }
          )
      }
      plot <- if (is.null(x = orig_groups)) {
        plot + labs(title = NULL)
      } else {
        plot + CenterTitle()
      }
    }
  )
  if (!is.null(x = split_by)) {
    ncol <- 1
  }
  if (combine) {
    plots <-
      patchwork::wrap_plots(
        plots,
        # %iff% infix (Seurat package)
        # Uses ncol if orig_groups is not NULL, otherwise uses NULL
        ncol = orig_groups %iff% ncol
      )
  }
  return(plots)
}
```

SCEPlots::DimPlot with FetchData
```{r}
#------- Function copied and adapted from Seurat package -----------------------
# https://github.com/satijalab/seurat

#' Dimensional reduction plot
#'
#' Graphs the output of a dimensional reduction technique on a 2D scatter plot where each point is a
#' cell and it's positioned based on the cell embeddings determined by the reduction technique. The function accepts both Seurat and SingleCellExperiment objects.
#' For Seurat objects, cells are colored by their identity class by default, and for
#' SingleCellExperiment objects, cells are colored by the first metadata column in
#' colData(). The metadata variable used for coloring cells can be changed with the group_by parameter).
#'
#' The code for this function was from the {\link[Seurat Package]{https://github.com/satijalab/seurat/blob/master/R/visualization.R}} and adapted for use with
#' {\link[SingleCellExperiment]{https://www.bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html}} objects.
#'
#' @param object  a Seurat object or a SingleCellExperiment object
#' @param dims Dimensions to plot, must be a two-length numeric vector specifying x- and y-dimensions i.e. c(1,2) to plot the first and second dimensions from the
#' reduction results.
#' @param cells Vector of cells to plot (default is all cells)
#' @param cols Vector of colors, each color corresponds to an identity class. This may also be a single character
#' or numeric value corresponding to a palette as specified by \code{\link[RColorBrewer]{brewer.pal.info}}.
#' By default, ggplot2 assigns colors. We also include a number of palettes from the pals package.
#' See \code{\link{DiscretePalette}} for details.
#' @param pt_size Adjust point size for plotting
#' @param reduction Which dimensionality reduction to use. If not specified, first searches for umap, then tsne, then pca
#' @param group_by Name of one or more metadata columns to group (color) cells by
#' (for example, orig.ident); pass 'ident' to group by identity class
#' @param split_by Name of a metadata column to split plot by;
#' see \code{\link{FetchData}} for more details
#' @param shape_by If NULL, all points are circles (default). You can specify any
#' cell attribute (that can be pulled with FetchData) allowing for both
#' different colors and different shapes on cells.  Only applicable if \code{raster = FALSE}.
#' @param order Specify the order of plotting for the idents. This can be
#' useful for crowded plots if points of interest are being buried. Provide
#' either a full list of valid idents or a subset to be plotted last (on top)
#' @param shuffle Whether to randomly shuffle the order of points. This can be
#' useful for crowded plots if points of interest are being buried. (default is FALSE)
#' @param seed Sets the seed if randomly shuffling the order of points.
#' @param label Whether to label the clusters
#' @param label_size Sets size of labels
#' @param label_color Sets the color of the label text
#' @param label_box Whether to put a box around the label text (geom_text vs
#' geom_label)
#' @param repel Repel labels
#' @param cells_highlight A list of character or numeric vectors of cells to
#' highlight. If only one group of cells desired, can simply
#' pass a vector instead of a list. If set, colors selected cells to the color(s)
#' in \code{cols_highlight} and other cells black (white if dark.theme = TRUE);
#' will also resize to the size(s) passed to \code{sizes_highlight}
#' @param cols_highlight A vector of colors to highlight the cells as; will
#' repeat to the length groups in cells_highlight
#' @param sizes_highlight Size of highlighted cells; will repeat to the length
#' groups in cells_highlight
#' @param na_value Color value for NA points when using custom scale
#' @param ncol Number of columns for display when combining plots
#' @param combine Combine plots into a single \code{\link[patchwork]{patchwork}ed}
#' ggplot object. If \code{FALSE}, return a list of ggplot objects
#' @param raster Convert points to raster format, default is \code{NULL} which
#' automatically rasterizes if plotting more than 100,000 cells
#' @param raster_dpi Pixel resolution for rasterized plots, passed to geom_scattermore().
#' Default is c(512, 512).
#'
#' @return A \code{\link[patchwork]{patchwork}ed} ggplot object if
#' \code{combine = TRUE}; otherwise, a list of ggplot objects
#'
#' @import rlang
#' @import Seurat
#' @importFrom ggplot2 facet_wrap vars sym labs
#' @importFrom SeuratObject DefaultDimReduc
#' @importFrom patchwork wrap_plots
#' @importFrom SingleCellExperiment reducedDimNames reducedDims colData
#'
#' @export
#'
DimPlot_FetchData <- function(
    object,
    dims = c(1, 2),
    cells = NULL,
    cols = NULL,
    pt_size = NULL,
    reduction = NULL,
    group_by = NULL,
    split_by = NULL,
    shape_by = NULL,
    order = NULL,
    shuffle = FALSE,
    seed = 1,
    label = FALSE,
    label_size = 4,
    label_color = 'black',
    label_box = FALSE,
    repel = FALSE,
    cells_highlight = NULL,
    cols_highlight = '#DE2D26',
    sizes_highlight = 1,
    na_value = 'grey50',
    ncol = NULL,
    combine = TRUE,
    raster = NULL,
    raster_dpi = c(512, 512)
) {
  if (length(x = dims) != 2) {
    stop("'dims' must be a two-length vector")
  }

  # Require group_by to be defined for SingleCellExperiment objects
  if (is(object, "SingleCellExperiment")){
    if (is.null(group_by)){
      stop("For SingleCellExperiment objects, `group_by` must be defined.")
    }
  }

  # 1. Define reduction (defaults to the first reduction stored for sce objects)
  # Uses rlang %||% infix
  reduction <- reduction %||% default_reduction(object)
  # 2. Define cells to include in plot
  ## Same as for Seurat object ##
  cells <- cells %||% get_all_cells(object)

  # Fetch dimensional reduction data from object
  # 3. Convert dims to format readable by FetchData (<reduction>_<dim>)
  dim_names <- reduction_dimnames(object, reduction = reduction, dims = dims)

  # 4. Identify group_by variable, store in orig_groups
  # orig_groups is used to test whether the group_by was set by the user
  orig_groups <- group_by
  # Ident does not exist for SingleCellExperiment objects, but this will never
  # be applied since group_by will always be defined.
  group_by <- group_by %||% 'ident'

  # 5. Fetch reduction coordinates and group by metadata
  data <-
    FetchData(
      object = object,
      vars = c(dim_names, group_by),
      cells = cells
      )

  # Throw an error if reduction coordinates or group_by data were not
  # properly returned
  if (!all(dim_names %in% colnames(data))) {
    stop("The dimensions requested were not found.", call. = FALSE)
  } else if (!all(group_by %in% colnames(data))){
    stop("The group_by variable(s) requested were not found.", call. = FALSE)
  }

  print("colnames of data")
  print(colnames(data))

  # 6. Define group_by variables to iterate through
  group_by_cols <-
    colnames(data)[3:ncol(data)]

  print("group_by_cols")
  print(group_by_cols)

  # 7. Convert group by columns to factors if they are not already
  print("7. Group by columns to factor")
  for (group in group_by_cols) {
    print(group)
    if (!is.factor(data[, group])) {
      data[, group] <- factor(data[, group])
    }
  }

  print("8. shape_by data")
  # 8. Add shape_by data if it exists
  if (!is.null(x = shape_by)) {
    data[, shape_by] <-
      FetchData(
        object = object,
        vars = shape_by,
        cells = cells
        )
  }

  # 9. Same for split_by data
  if (!is.null(x = split_by)) {
    data[, split_by] <-
      FetchData(
        object = object,
        vars = split_by,
        cells = cells
        )
  }

  # 10. If shufffle is TRUE, randomly shuffle cells
  if (isTRUE(shuffle)) {
    set.seed(seed = seed)
    data <- data[sample(x = 1:nrow(x = data)), ]
  }

  # # Compile data for plotting: methods depend on object type
  # if (is(object, "SingleCellExperiment")){
  #   # For SingleCellExperiment objects
  #   # 1. Define reduction (defaults to the first reduction stored for sce objects)
  #   # Uses rlang %||% infix
  #   reduction <- reduction %||% SingleCellExperiment::reducedDimNames(object)[1]
  #   # 2. Define cells to include in plot
  #   ## Same as for seurat object ##
  #   cells <- cells %||% BiocGenerics::colnames(object)
  #
  #   # 3. Fetch dimensional reduction data from object
  #   data <- SingleCellExperiment::reducedDims(object)[[reduction]][cells, dims]
  #   data <- BiocGenerics::as.data.frame(data)
  #
  #   # 4. Fetch names of dimensions to plot
  #   # For SCE objects, use the column names for the requested dim indices
  #   # (there is no `Key()` method for SingleCellExperiment objects)
  #   dim_names <- colnames(data)[dims]
  #
  #   # 5. Process group by selection
  #   # There is no "ident" property for SingleCellExperiment objects
  #   # Store original entry for group_by
  #   orig_groups <- group_by
  #
  #   if (is.null(group_by)){
  #     stop("group_by must not be NULL for SingleCellExperiment objects.")
  #   }
  #
  #   # 6. Bind group by metadata to the table of reduction coordinates
  #   data <-
  #     cbind(
  #       data,
  #       # Subsets for selected cells, and the names of entered group_by columns
  #       colData(object)[cells, group_by, drop = FALSE]
  #     )
  #
  #
  #
  #
  # } else if (is(object, "Seurat")){
  #   # For Seurat Objects
  #   # Determine reduction to use (if NULL, use default))
  #   # %||% infix is from rlang
  #   reduction <- reduction %||% DefaultDimReduc(object = object)
  #   # Read parameter for cells to plot (defaults to all cells)
  #   cells <- cells %||% colnames(x = object)
  #
  #   # Fetch data for chosen reduction from object
  #   # subset for chosen cells and dims
  #   data <- Embeddings(object = object[[reduction]])[cells, dims]
  #   # Convert to data.frame (default is a matrix)
  #   data <- as.data.frame(x = data)
  #   # Form names for dim reduction coordinates on the x- and y- axis
  #   dim_names <-
  #     paste0(
  #       # Use the key of the *reduction* chosen by the
  #       # user (or the default reduction)
  #       Key(object = object[[reduction]]),
  #       dims
  #     )
  #
  #   # Set group by to the current ident class if it is NULL
  #   # Store current ident class
  #   object[['ident']] <- Idents(object = object)
  #   # Store group by variable in `orig_groups`
  #   orig_groups <- group_by
  #   group_by <- group_by %||% 'ident'
  #
  #   # Add values of the group_by metadata variable(s) for
  #   # each cell to the reduction data
  #   data <-
  #     cbind(
  #       data,
  #       object[[group_by]][cells, , drop = FALSE]
  #     )
  #
  #   # Explicitly define group_by as the column names for each metadata variable
  #   # added to the reduction matrix above
  #   group_by_cols <- colnames(x = data)[3:ncol(x = data)]
  #
  #   # If any of the metadata columns are not factors, coerce them into factors.
  #   for (group in group_by) {
  #     if (!is.factor(x = data[, group])) {
  #       data[, group] <- factor(x = data[, group])
  #     }
  #   }
  #
  #   # Add data for shape_by metadata variable if it exists
  #   if (!is.null(x = shape_by)) {
  #     data[, shape_by] <- object[[shape_by, drop = TRUE]]
  #   }
  #
  #   # Same for split_by metadata variable
  #   if (!is.null(x = split_by)) {
  #     data[, split_by] <- object[[split_by, drop = TRUE]]
  #   }
  #
  #   # Randomly shuffle cells if specified by the user
  #   if (isTRUE(x = shuffle)) {
  #     set.seed(seed = seed)
  #     data <- data[sample(x = 1:nrow(x = data)), ]
  #   }
  # } else {
  #   # Throw an error for unsupported data types
  #   stop("Object entered is not a SinglecellExperiment or a Seurat object.")
  # }

  # For each group by variable, create a DimPlot of cells grouped by that variable.
  plots <- lapply(
    X = group_by_cols,
    FUN = function(group) {
      plot <- Seurat::SingleDimPlot(
        data = data[, c(dim_names, group, split_by, shape_by)],
        dims = dim_names,
        col.by = group,
        # cols: a categorical pallete in this case
        cols = cols,
        pt.size = pt_size,
        shape.by = shape_by,
        order = order,
        label = FALSE,
        # Cells to highlight
        cells.highlight = cells_highlight,
        cols.highlight = cols_highlight,
        sizes.highlight = sizes_highlight,
        na.value = na_value,
        raster = raster,
        raster.dpi = raster_dpi
      )
      if (label) {
        plot <-
          Seurat::LabelClusters(
            plot = plot,
            id = group,
            repel = repel,
            size = label_size,
            split.by = split_by,
            box = label_box,
            color = label_color
          )
      }
      if (!is.null(x = split_by)) {
        plot <-
          plot +
          Seurat:::FacetTheme() +
          ggplot2::facet_wrap(
            # rlang injection operator
            # ?`!!` for more information
            facets = vars(!!sym(x = split_by)),
            ncol = if (length(x = group_by) > 1 || is.null(x = ncol)) {
              length(x = unique(x = data[, split_by]))
            } else {
              ncol
            }
          )
      }
      plot <- if (is.null(x = orig_groups)) {
        plot + labs(title = NULL)
      } else {
        plot + CenterTitle()
      }
    }
  )
  if (!is.null(x = split_by)) {
    ncol <- 1
  }
  if (combine) {
    plots <-
      patchwork::wrap_plots(
        plots,
        # %iff% infix (Seurat package)
        # Uses ncol if orig_groups is not NULL, otherwise uses NULL
        ncol = orig_groups %iff% ncol
        )
  }
  return(plots)
}

```


```{r}
library(tictoc)
library(Seurat)
library(rlang)

# Function: performs n calls of a function and records the time taken for each
# call. Returns the time for each run in a numeric vector.
repeat_trial <- 
  function(func, ..., n){
    time <- c()
    
    for (i in 1:n){
      cat(paste0("Trial ", i, "\n"))
      
      tic()
      suppressMessages(
        do.call(
        func,
        args = list(...)
        )
      )
      
      
      suppressMessages(elapsed <- toc())
  
      time <- 
        c(time, as.numeric(elapsed$toc - elapsed$tic))
    }
    
    time
  }

#' Function to run trials on each function
#'
#' @param funcs a named vector of functions to run. Time trial results are 
#' returned for each function, labeled according to the names passed.
#' @param params A vector of lists of parameters passed to each function. The length of
#' the list must match the length of funs
#' @param n the number of trials to run for each function
multi_time_trial <- function(funcs, params, n){
  test <- c()
  time <- c()
  
  if (!length(funcs) == length(params)){
    stop("funcs and params must be of equal length.")
  }
  
  for (i in 1:length(funcs)){
    func_results <- 
      repeat_trial(
      func = funcs[i], 
      n = n,
      params[i]
      )
    
    time <- c(time, func_results)
    test <- c(test, rep_len(names(funcs)[i], 100))
  }
  
  # Construct data.frame from results and return
  data.frame(
    list(
    "Test" = test, 
    "Time" = time
    )
  )
}

# time_data <- 
#   multi_time_trial(
#     funcs = 
#       c("SCEPlots_seurat" = SCEPlots::DimPlot,
#         "SCEPlots_SCE" = SCEPlots::DimPlot)
#   )

test <- c()
time <- c()

# Full AML Seurat object, latest SCEPlots function
results <- 
  repeat_trial(
    func = SCEPlots::DimPlot, 
    n = 100,
    object = sobj,
    group_by = "velten_clusters"
    )

time <- c(time, results)
test <- c(test, rep_len("SCEPlots_seurat", 100))

# Full AML SCE object, latest SCEPlots function
results <- 
  repeat_trial(
    func = SCEPlots::DimPlot, 
    n = 100,
    object = sce,
    group_by = "velten_clusters"
    )

time <- c(time, results)
test <- c(test, rep_len("SCEPlots_SCE", 100))

# Full AML Seurat object, SCEPlots v1
results <- 
  repeat_trial(
    func = DimPlot_FetchData, 
    n = 100,
    object = sobj,
    group_by = "velten_clusters"
    )

time <- c(time, results)
test <- c(test, rep_len("SCEPlots_orig_seurat", 100))

# Full AML SCE object, SCEPlots v1
results <- 
  repeat_trial(
    func = DimPlot_FetchData, 
    n = 100,
    object = sce,
    group_by = "velten_clusters"
    )

time <- c(time, results)
test <- c(test, rep_len("SCEPlots_orig_SCE", 100))

# Full AML Seurat object, SCEPlots v1
results <- 
  repeat_trial(
    func = DimPlot_orig, 
    n = 100,
    object = sobj,
    group_by = "velten_clusters"
    )

time <- c(time, results)
test <- c(test, rep_len("SCEPlots_orig_seurat", 100))

# Full AML SCE object, SCEPlots v1
results <- 
  repeat_trial(
    func = DimPlot_orig, 
    n = 100,
    object = sce,
    group_by = "velten_clusters"
    )

time <- c(time, results)
test <- c(test, rep_len("SCEPlots_orig_SCE", 100))

# Full AML Seurat object, Seurat
results <- 
  repeat_trial(
    func = Seurat::DimPlot, 
    n = 100,
    object = sobj,
    group.by = "velten_clusters"
    )

time <- c(time, results)
test <- c(test, rep_len("seurat_seurat", 100))

# for (i in 1:100){
#   cat(paste0("Trial ", i))
#   
#   suppressMessages({
#   # SCEPlots with a Seurat object
#   tic()
#   SCEPlots::DimPlot(sobj, group_by = "velten_clusters")
#   elapsed <- toc()
#   
#   test <-
#     c(test, "SCEPlots_seurat")
#   time <- 
#     c(time, as.numeric(elapsed$toc - elapsed$tic))
#   })
#   
#   cat("\r")
# }
# 
# for (i in 1:100){
#   cat(paste0("Trial ", i))
#   
#   suppressMessages({
#   
#   # SCEPlots with an SCE object
#   tic()
#   SCEPlots::DimPlot(sce, group_by = "velten_clusters")
#   elapsed <- toc()
#   
#   test <-
#     c(test, "SCEPlots_SCE")
#   time <- 
#     c(time, as.numeric(elapsed$toc - elapsed$tic))
#   })
#   
#   cat("\r")
# }
# 
# for (i in 1:100){
#   cat(paste0("Trial ", i))
#   
#   suppressMessages({
#   # Seurat with a Seurat object
#   tic()
#   Seurat::DimPlot(sobj, group.by = "velten_clusters")
#   elapsed <- toc()
#   
#   test <-
#     c(test, "Seurat_seurat")
#   time <- 
#     c(time, as.numeric(elapsed$toc - elapsed$tic))
#   })
#   
#   cat("\r")
# }

# Construct a data frame from the results
time_data <-
  data.frame(
    list(
    "Test" = test, 
    "Time" = time
    )
  )

# Print a summary table with the average time taken for each function
time_data |> 
  group_by(Test) |> 
  summarize(
    average_time = mean(Time)
  )

ggplot(data = time_data, aes(x = Test, y = Time)) +
  geom_boxplot(aes(fill = Test)) #+
  #scale_color_discrete(c("#880000", "#898800", "#000088"))
```

# Trial of FetchData for reductions

Part 1: Seurat Object vs. SingleCellExperiment objects

```{r}
time <- c()
test <- c()

dimnames <- c("UMAP_1", "UMAP_2")

# Seurat objects
results <- 
  repeat_trial(
    func = FetchData, 
    n = 100,
    object = sobj,
    vars = dimnames
    )

time <- c(time, results)
test <- c(test, rep_len("FetchData_Seurat", 100))

# SCE objects
results <- 
  repeat_trial(
    func = FetchData, 
    n = 100,
    object = sce,
    vars = dimnames
    )

time <- c(time, results)
test <- c(test, rep_len("FetchData_SCE", 100))

fetchdata_results <-
  data.frame(
    list(
    "Test" = test, 
    "Time" = time
    )
  )

ggplot(data = fetchdata_results, aes(x = Test, y = Time)) +
  geom_boxplot(aes(fill = Test)) #+
  scale_color_manual(
    values = 
      c("#880000", "#000088"),
    aesthetics = "fill",
    na.value = "grey50"
    )
```

Part 2: Compare FetchData to direct accession of reduction coordinates for both objects

```{r}
# Function to fetch reduction coordinates for SingleCellExperiment obejcts
direct_accession_sce <- 
  function(object, reduction, dims = c(1,2)){
    cells <- colnames(object)
    
    data <- reducedDims(object)[[reduction]][cells, dims]
    as.data.frame(data)
  }

# Equivalent for Seurat objects (taken from Seurat::DimPlot)
direct_accession_seurat <- 
  function(object, reduction, dims = c(1,2)){
    # Include all cells
    cells <- colnames(object)
    
    data <- Embeddings(object = object[[reduction]])[cells, dims]
    as.data.frame(x = data)
  }

# Trials of each function, compared to fetchdata
time <- c()
test <- c()

dimnames <- c("UMAP_1", "UMAP_2")

reduction_sobj <- "umap"
reduction_sce <- "UMAP"

# FetchData, Seurat objects
results <- 
  repeat_trial(
    func = FetchData, 
    n = 100,
    object = sobj,
    vars = dimnames
    )

time <- c(time, results)
test <- c(test, rep_len("FetchData_Seurat", 100))

# FetchData, SCE objects
results <- 
  repeat_trial(
    func = FetchData, 
    n = 100,
    object = sce,
    vars = dimnames
    )

time <- c(time, results)
test <- c(test, rep_len("FetchData_SCE", 100))

# Direct accession, Seurat objects
results <- 
  repeat_trial(
    func = direct_accession_seurat, 
    n = 100,
    object = sobj,
    reduction = reduction_sobj
    )

time <- c(time, results)
test <- c(test, rep_len("Direct_accession_Seurat", 100))

# Direct accession, SCE objects
results <- 
  repeat_trial(
    func = direct_accession_sce, 
    n = 100,
    object = sce,
    reduction = reduction_sce
    )

time <- c(time, results)
test <- c(test, rep_len("Direct_accession_SCE", 100))

direct_acc_v_fetchdata <-
  data.frame(
    list(
    "Test" = test, 
    "Time" = time
    )
  )

direct_acc_v_fetchdata$Test <- 
  factor(
    direct_acc_v_fetchdata$Test, 
    levels = 
      c("FetchData_SCE", 
        "Direct_accession_SCE", 
        "FetchData_Seurat",
        "Direct_accession_Seurat" 
        )
    )

ggplot(data = direct_acc_v_fetchdata, aes(x = Test, y = Time)) +
  geom_boxplot(aes(color = Test)) +
  scale_color_manual(
    values = 
      c("#880000", "#000088", "#008800", "#B8AB2F"),
    aesthetics = "color",
    na.value = "grey50"
    )
```

